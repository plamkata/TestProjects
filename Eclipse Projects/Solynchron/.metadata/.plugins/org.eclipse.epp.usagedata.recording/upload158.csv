what,kind,bundleId,bundleVersion,description,time
executed,command,org.eclipse.ui,3.5.1.M20090902-1000,"org.eclipse.ui.edit.delete",1254995268524
executed,command,org.eclipse.ui,3.5.1.M20090902-1000,"org.eclipse.ui.edit.delete",1254995268556
error,log,,,"All Source code being worked on:\r\n----------------------------------- SOURCE BEGIN -------------------------------------\r\npackage com.startup.solynchron.dao;\r\n\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\n\r\n/**\r\n * TODO: migrate logic instantiation to OSGI style instantiation\r\n * \r\n * @author plamKaTa\r\n *\r\n */\r\npublic class LogicManager<> {\r\n\t\r\n\tpublic static final String RECORD_LOGIC = ""record"";\r\n\t\r\n\tpublic static final String PROBLEM_LOGIC = ""problem"";\r\n\t\r\n\tprivate static Map<String, ILogic> logicRegistry = \r\n\t\tnew HashMap<String, ILogic>();\r\n\t\r\n\tstatic {\r\n\t\tregister(RECORD_LOGIC, new RecordLogic());\r\n\t\t\r\n\t}\r\n\t\r\n\tpublic static void register(String key, ILogic logic) {\r\n\t\tlogicRegistry.put(key, logic);\r\n\t}\r\n\t\r\n\tpublic static void deregister(String key) {\r\n\t\tlogicRegistry.remove(key);\r\n\t}\r\n\t\r\n\tpublic static T get(String key) {\r\n\t\treturn (T) logicRegistry.get(key);\r\n\t}\r\n\r\n}\r\n\r\n----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------\r\n/*******************************************************************************\r\n * This program and the accompanying materials\r\n * are made available under the terms of the Eclipse Public License v1.0\r\n * which accompanies this distribution, and is available at\r\n * http://www.eclipse.org/legal/epl-v10.html\r\n *\r\n * Contributors:\r\n *     Marco van Meegen - initial API and implementation\r\n *\r\n ******************************************************************************\r\n */\r\n\r\npackage net.sf.rcpforms.examples.complete;\r\n\r\nimport java.util.Date;\r\n\r\nimport net.sf.rcpforms.bindingvalidation.ValidationManager;\r\nimport net.sf.rcpforms.bindingvalidation.forms.RCPFormFactory;\r\nimport net.sf.rcpforms.bindingvalidation.forms.RCPFormPart;\r\nimport net.sf.rcpforms.common.NullValue;\r\nimport net.sf.rcpforms.common.util.Validate;\r\nimport net.sf.rcpforms.examples.complete.TestModel.Gender;\r\nimport net.sf.rcpforms.modeladapter.tables.ObservableTreeListBeanContentProvider;\r\nimport net.sf.rcpforms.tablesupport.tables.ColumnConfiguration;\r\nimport net.sf.rcpforms.tablesupport.tables.ECellEditorType;\r\nimport net.sf.rcpforms.tablesupport.tables.TableUtil;\r\nimport net.sf.rcpforms.widgetwrapper.builder.GridBuilder;\r\nimport net.sf.rcpforms.widgetwrapper.builder.GridLayoutFactory;\r\nimport net.sf.rcpforms.widgetwrapper.wrapper.EControlState;\r\nimport net.sf.rcpforms.widgetwrapper.wrapper.RCPCheckboxTable;\r\nimport net.sf.rcpforms.widgetwrapper.wrapper.RCPComposite;\r\nimport net.sf.rcpforms.widgetwrapper.wrapper.RCPPushButton;\r\nimport net.sf.rcpforms.widgetwrapper.wrapper.RCPSection;\r\nimport net.sf.rcpforms.widgetwrapper.wrapper.RCPTable;\r\nimport net.sf.rcpforms.widgetwrapper.wrapper.RCPTree;\r\n\r\nimport org.eclipse.core.databinding.Binding;\r\nimport org.eclipse.core.databinding.observable.list.WritableList;\r\nimport org.eclipse.jface.databinding.swt.SWTObservables;\r\nimport org.eclipse.jface.viewers.ITreeContentProvider;\r\nimport org.eclipse.jface.viewers.TableViewer;\r\nimport org.eclipse.jface.viewers.TreeViewer;\r\nimport org.eclipse.jface.viewers.Viewer;\r\nimport org.eclipse.swt.SWT;\r\nimport org.eclipse.swt.events.SelectionAdapter;\r\nimport org.eclipse.swt.events.SelectionEvent;\r\nimport org.eclipse.swt.layout.GridData;\r\nimport org.eclipse.swt.widgets.Composite;\r\nimport org.eclipse.swt.widgets.Display;\r\nimport org.eclipse.ui.forms.widgets.FormToolkit;\r\n\r\n/**\r\n * Example part demonstrating the advanced table features of RCPForms.\r\n * <p>\r\n * <ul>\r\n * <li>creating an editable table just by configuring the column properties, no coding needed\r\n * <li>how converters from data binding are automatically used to render table data\r\n * <li>binding of multi selection state of a checkbox table to a list\r\n * <li>binding of multi selection state of a normal table to a list\r\n * <li>automatic creation of a table cursor if the table contains editable columns\r\n * <li>disabled rows if {@link RCPTableFormToolkit} is used\r\n * </ul>\r\n * \r\n * @author Marco van Meegen\r\n */\r\npublic class SandboxTablePart extends RCPFormPart\r\n{\r\n    private RCPSection mainSection;\r\n\r\n    private RCPCheckboxTable m_CheckboxTable;\r\n\r\n    private RCPTable m_Table;\r\n\r\n    private RCPTable m_TableCursorSupport;\r\n\r\n    private RCPPushButton m_addColumn;\r\n\r\n    private RCPPushButton m_removeColumn;\r\n\r\n    private RCPPushButton m_toggleIsSelectable;\r\n\r\n    private RCPPushButton m_removeInput;\r\n\r\n    private TableViewer m_CheckboxTableViewer;\r\n\r\n    private TableViewer m_TableViewer;\r\n\r\n    private TableViewer m_TableViewerCursorSupport;\r\n\r\n    private RCPTree m_TreeTable;\r\n\r\n    private RCPTree m_CheckboxTreeTable;\r\n\r\n    private TreeViewer m_TreeTableViewer;\r\n\r\n    private TreeViewer m_checkedTreeTableViewer;\r\n\r\n    private TableModel dataModel;\r\n\r\n    private Binding tableCheckBinding;\r\n\r\n    public SandboxTablePart()\r\n    {\r\n        m_addColumn = new RCPPushButton(""add item"");\r\n        m_removeColumn = new RCPPushButton(""remove item"");\r\n        m_toggleIsSelectable = new RCPPushButton(""toggle selectable"");\r\n        m_removeInput = new RCPPushButton(""replace data"");\r\n\r\n        m_CheckboxTable = new RCPCheckboxTable(""CheckboxTable:"");\r\n        m_Table = new RCPTable(""Table:"");\r\n        m_TableCursorSupport = new RCPTable(""Table with cursor support:"");\r\n\r\n        // m_TreeTable = new RCPTree(""TreeTable:"", SWT.FULL_SELECTION);\r\n        // m_CheckboxTreeTable = new RCPTree(""CheckboxTreeTable:"", SWT.FULL_SELECTION | SWT.CHECK);\r\n\r\n    }\r\n\r\n    private static ColumnConfiguration[] createColumnConfigurations(boolean editable)\r\n    {\r\n        // this configures the table with the attributes to display;\r\n        // automatic conversion will be applied using the standard data binding converters\r\n        // which are used in text fields too\r\n        Object[] values = new Object[Gender.values().length + 1];\r\n        // add null value\r\n        values[0] = NullValue.getInstance();\r\n        System.arraycopy(Gender.values(), 0, values, 1, values.length - 1);\r\n        ColumnConfiguration[] columnConfigurations = {\r\n                new ColumnConfiguration(""Name"", TestModel.P_Name, 100, SWT.LEFT, false,\r\n                        editable ? ECellEditorType.TEXT : null).setGrabHorizontal(true),\r\n                new ColumnConfiguration(""Geburtsdatum"", TestModel.P_BirthDate, 80, SWT.LEFT, false,\r\n                        editable ? ECellEditorType.DATE : null),\r\n                editable ? new ColumnConfiguration(""Geschlecht"", TestModel.P_Gender, 60, SWT.LEFT,\r\n                        values) : new ColumnConfiguration(""Geschlecht"", TestModel.P_Gender, 60,\r\n                        SWT.LEFT),\r\n                new ColumnConfiguration(""Kontoüberzug"", TestModel.P_OverdrawAccount, 50,\r\n                        SWT.CENTER, false, editable ? ECellEditorType.CHECK : null),\r\n                new ColumnConfiguration(""Kinder"", TestModel.P_ChildCount, 50, SWT.RIGHT, false,\r\n                        editable ? ECellEditorType.TEXT : null),\r\n                new ColumnConfiguration(""Kontostand"", TestModel.P_AccountBalance, 70, SWT.RIGHT,\r\n                        false, editable ? ECellEditorType.TEXT : null)};\r\n        Validate.noNullElements(columnConfigurations,\r\n                ""ColumnConfigurations must not have null elements"");\r\n        return columnConfigurations;\r\n    }\r\n\r\n    @Override\r\n    public void createUI(FormToolkit formToolkit, Composite parent)\r\n    {\r\n        GridBuilder builder = new GridBuilder(formToolkit, parent, 1);\r\n        mainSection = new RCPSection(""Sandbox Table Section"");\r\n        GridBuilder sectionBuilder = builder.addContainer(mainSection, 2);\r\n        RCPComposite buttonPanel = new RCPComposite();\r\n        GridBuilder buttonWidgetFactory = sectionBuilder.fill(1).addContainer(buttonPanel, 8);\r\n        buttonWidgetFactory.add(m_addColumn);\r\n        m_addColumn.getSWTButton().addSelectionListener(new SelectionAdapter()\r\n        {\r\n            @Override\r\n            public void widgetSelected(SelectionEvent e)\r\n            {\r\n                addRandomItem();\r\n            }\r\n        });\r\n\r\n        buttonWidgetFactory.add(m_removeColumn);\r\n        m_removeColumn.getSWTButton().addSelectionListener(new SelectionAdapter()\r\n        {\r\n            @Override\r\n            public void widgetSelected(SelectionEvent e)\r\n            {\r\n                removeFirstItem();\r\n            }\r\n        });\r\n\r\n        buttonWidgetFactory.add(m_toggleIsSelectable);\r\n        m_toggleIsSelectable.getSWTButton().addSelectionListener(new SelectionAdapter()\r\n        {\r\n            @Override\r\n            public void widgetSelected(SelectionEvent e)\r\n            {\r\n                toggleSelectableState();\r\n            }\r\n        });\r\n        m_toggleIsSelectable.getSWTButton().setToolTipText(\r\n                ""removes all selections and toggle selectable state"");\r\n\r\n        buttonWidgetFactory.add(m_removeInput);\r\n        m_removeInput.getSWTButton().addSelectionListener(new SelectionAdapter()\r\n        {\r\n            @Override\r\n            public void widgetSelected(SelectionEvent e)\r\n            {\r\n                removeList();\r\n            }\r\n        });\r\n        m_removeInput.getSWTButton().setToolTipText(""replaces the list of the second table"");\r\n\r\n        // create normal Table with table cursor support\r\n        sectionBuilder.add(m_TableCursorSupport);\r\n        m_TableViewerCursorSupport = TableUtil.configureTableViewer(\r\n                (TableViewer) m_TableCursorSupport.getViewer(), createColumnConfigurations(true),\r\n                TestModel.class, false, true);\r\n\r\n        // create normal Table\r\n        sectionBuilder.add(m_Table);\r\n        m_TableViewer = TableUtil.configureTableViewer((TableViewer) m_Table.getViewer(),\r\n                createColumnConfigurations(true), TestModel.class, false, false);\r\n\r\n        // create Checkbox Table\r\n        sectionBuilder.add(m_CheckboxTable);\r\n        GridData gd = GridLayoutFactory.createDefaultLayoutData();\r\n        gd.grabExcessHorizontalSpace = true;\r\n        gd.grabExcessVerticalSpace = true;\r\n        gd.horizontalAlignment = SWT.FILL;\r\n//        gd.verticalIndent = SWT.FILL;\r\n        //show 3 columns with data and the header column\r\n        gd.heightHint = sectionBuilder.getHeightHint(3);\r\n        gd.heightHint += m_CheckboxTable.getSWTTable().getHeaderHeight();\r\n        \r\n        m_CheckboxTable.getSWTTable().setLayoutData(gd);\r\n        ColumnConfiguration[] columnConfigurations = createColumnConfigurations(false);\r\n        columnConfigurations[0].enableColumnSorting(false);\r\n        columnConfigurations[2].enableColumnSorting(false);\r\n        m_CheckboxTableViewer = TableUtil.configureTableViewer((TableViewer) m_CheckboxTable\r\n                .getViewer(), columnConfigurations, TestModel.class, false, false);\r\n\r\n        // create table tree\r\n        // sectionBuilder.add(m_TreeTable);\r\n        // class SampleObservableTreeListBeanContentProvider extends\r\n        // ObservableTreeListBeanContentProvider{\r\n        //            \r\n        // public Object[] getChildren(Object parentElement)\r\n        // {\r\n        // return new Object[]{generateNewDataModelItem(), generateNewDataModelItem()};\r\n        // }\r\n        //\r\n        // public Object getParent(Object element)\r\n        // {\r\n        // return null;\r\n        // }\r\n        //\r\n        // public boolean hasChildren(Object element)\r\n        // {\r\n        // return ((TestModel) element).getName().equals(""Mueller"");\r\n        // }\r\n        //\r\n        // public Object[] getElements(Object inputElement)\r\n        // {\r\n        // return dataModel.getList().toArray();\r\n        // }\r\n        //\r\n        // public void dispose()\r\n        // {\r\n        // }\r\n        // };\r\n        // m_TreeTableViewer =\r\n        // TableUtil.configureTreeTableViewer((TreeViewer)m_TreeTable.getViewer(),\r\n        // (ITreeContentProvider)new SampleObservableTreeListBeanContentProvider(),\r\n        // createColumnConfigurations(true), TestModel.class, false);\r\n        //        \r\n        // //create checked table tree\r\n        // sectionBuilder.add(m_CheckboxTreeTable);\r\n        // m_checkedTreeTableViewer =\r\n        // TableUtil.configureTreeTableViewer((TreeViewer)m_CheckboxTreeTable.getViewer(),\r\n        // (ITreeContentProvider)new SampleObservableTreeListBeanContentProvider(),\r\n        // createColumnConfigurations(false), TestModel.class, false);\r\n\r\n    }\r\n\r\n    @Override\r\n    public void bind(ValidationManager context, Object modelBean)\r\n    {\r\n        Validate.isTrue(modelBean instanceof TableModel);\r\n        this.dataModel = (TableModel) modelBean;\r\n\r\n        // set normal table viewers input\r\n        m_TableViewerCursorSupport.setInput(dataModel.getList());\r\n        m_TableViewer.setInput(dataModel.getList());\r\n        // bind selection to table; if its checkbox table, the check state is bound,\r\n        // otherwise the multi selection of rows.\r\n        context.bindSelection(m_TableCursorSupport, dataModel.getSelectedList());\r\n        tableCheckBinding = context.bindSelection(m_Table, dataModel.getSelectedList());\r\n\r\n        // set the CheckboxViewer's input\r\n        m_CheckboxTableViewer.setInput(dataModel.getList());\r\n\r\n        // bind selection to table; if its checkbox table, the check state is bound,\r\n        // otherwise the multi selection of rows.\r\n        context.bindSelection(m_CheckboxTable, dataModel.getSelectedList());\r\n\r\n        // set the TreeViewer's input\r\n        // m_TreeTableViewer.setInput(dataModel.getList());\r\n        // m_checkedTreeTableViewer.setInput(dataModel.getList());\r\n\r\n    }\r\n\r\n    private void removeFirstItem()\r\n    {\r\n        if (dataModel.getList().size() > 0)\r\n        {\r\n            dataModel.getList().remove(m_CheckboxTableViewer.getElementAt(0));\r\n        }\r\n    }\r\n\r\n    private void addRandomItem()\r\n    {\r\n        dataModel.getList().add(this.generateNewDataModelItem());\r\n    }\r\n\r\n    private TestModel generateNewDataModelItem()\r\n    {\r\n        // generate Geschlechtscode\r\n        Gender geschlecht = null;\r\n        switch ((int) (Math.random() * 10000) % 3)\r\n        {\r\n            case 0:\r\n                geschlecht = Gender.FEMALE;\r\n                break;\r\n            case 1:\r\n                geschlecht = Gender.MALE;\r\n                break;\r\n            default:\r\n                geschlecht = Gender.UNKNOWN;\r\n                break;\r\n        }\r\n\r\n        return new TestModel(""Mueller - "" + (int) (Math.random() * 1000), new Date((long) (Math\r\n                .random() * 1100000000000L)), (int) (Math.random() * 1000) % 2 == 0 ? true : false,\r\n                (int) (Math.random() * 1000) % 5, Math.random() * 10000, geschlecht, (int) (Math\r\n                        .random() * 1000) % 2 == 0 ? true : false);\r\n    }\r\n\r\n    private void toggleSelectableState()\r\n    {\r\n        // clear all selections\r\n        WritableList wl = dataModel.getList();\r\n        for (int i = 0; i < wl.size(); ++i)\r\n        {\r\n            TestModel s2dm = (TestModel) wl.get(i);\r\n            s2dm.setIsSelectable(s2dm.getIsSelectable() ? false : true);\r\n        }\r\n\r\n        // Problem -> fires no event... manual refresh...\r\n        m_TableViewerCursorSupport.refresh(true, true);\r\n        m_CheckboxTableViewer.refresh(true, true);\r\n        m_TableViewer.refresh(true, true);\r\n    }\r\n\r\n    private void removeList()\r\n    {\r\n        // unbind checkedList from table\r\n        if (tableCheckBinding != null)\r\n        {\r\n            tableCheckBinding.dispose();\r\n            tableCheckBinding = null;\r\n        }\r\n\r\n        // m_TableViewer.setInput(null);\r\n        WritableList newList = new WritableList(SWTObservables.getRealm(Display.getDefault()));\r\n        for (int i = 0; i < 10; ++i)\r\n        {\r\n            newList.add(this.generateNewDataModelItem());\r\n        }\r\n        m_TableViewer.setInput(newList);\r\n    }\r\n\r\n    public static void main(String[] args)\r\n    {\r\n        final TableModel model = new TableModel();\r\n        final RCPFormPart part = new SandboxTablePart();\r\n        RCPFormFactory.getInstance().startTestShell(""SandboxTablePart"", part, model);\r\n    }\r\n\r\n    @Override\r\n    public void setState(EControlState state, boolean value)\r\n    {\r\n        mainSection.setState(state, value);\r\n\r\n    }\r\n}\r\n\r\n----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------\r\n/*******************************************************************************\r\n * This program and the accompanying materials\r\n * are made available under the terms of the Eclipse Public License v1.0\r\n * which accompanies this distribution, and is available at\r\n * http://www.eclipse.org/legal/epl-v10.html\r\n *\r\n * Contributors:\r\n *     Marco van Meegen - initial API and implementation\r\n *\r\n ******************************************************************************\r\n */\r\n\r\npackage net.sf.rcpforms.examples.complete;\r\n\r\nimport java.util.Arrays;\r\nimport java.util.Date;\r\n\r\nimport net.sf.rcpforms.common.util.Validate;\r\nimport net.sf.rcpforms.examples.complete.TestModel.Gender;\r\n\r\nimport org.eclipse.core.databinding.observable.Realm;\r\nimport org.eclipse.core.databinding.observable.list.IListChangeListener;\r\nimport org.eclipse.core.databinding.observable.list.ListChangeEvent;\r\nimport org.eclipse.core.databinding.observable.list.WritableList;\r\nimport org.eclipse.jface.databinding.swt.SWTObservables;\r\nimport org.eclipse.swt.widgets.Display;\r\n\r\nimport com.damnhandy.aspects.bean.Observable;\r\n\r\n/**\r\n * Class TableModel represents the presentation model for the table part. WritableList is used,\r\n * since notification is built-in and much more efficient than bean indexed property notification.\r\n * \r\n * @author Marco van Meegen\r\n * @author Remo Loetscher\r\n */\r\n@Observable\r\npublic class TableModel \r\n{\r\n\r\n    public static final String P_DIRTY = ""dirty"";\r\n    public static final String P_TEST_MODEL = ""testModel"";\r\n\r\n    IListChangeListener listChangeListener = new IListChangeListener()\r\n    {\r\n\r\n        public void handleListChange(ListChangeEvent event)\r\n        {\r\n            // not interested in which kind of change,\r\n            // only that it was changed!\r\n            firePropertyChange(TableModel.P_DIRTY, null, null);\r\n        }\r\n    };\r\n\r\n    /** list of elements to display in the table */\r\n    private WritableList list;\r\n\r\n    /** list of elements which are checked/selected in the table */\r\n    private WritableList selectedList;\r\n    \r\n    /** variable used for master detail binding and therefore it has to be initalised, not null! */\r\n    private TestModel testModel = new TestModel();\r\n\r\n    public TableModel()\r\n    {\r\n        this(SWTObservables.getRealm(Display.getDefault()));\r\n        TestModel[] list = {\r\n                new TestModel(""Mueller"", new Date(10000000000L), true, 0, 1000.0, Gender.UNKNOWN, true),\r\n                new TestModel(""Meier1"", new Date(20000000000L), false, 2, 500.0, Gender.MALE, true),\r\n                new TestModel(""Meier2"", new Date(100000000000L), false, 2, 123.0, Gender.FEMALE, false),\r\n                new TestModel(""Meier3"", new Date(40000000000L), false, 2, 11000.0, Gender.UNKNOWN, true),\r\n                new TestModel(""Meier4"", new Date(30000000000L), false, 2, 2.0, Gender.UNKNOWN, false)};\r\n        this.list.addAll(Arrays.asList(list));\r\n    }\r\n    \r\n    public TestModel getTestModel()\r\n    {\r\n        return testModel;\r\n    }\r\n    \r\n    public void setTestModel(TestModel newModel)\r\n    {\r\n        testModel = newModel;\r\n    }\r\n\r\n    /**\r\n     * create writable lists using given realm\r\n     */\r\n    public TableModel(Realm realm)\r\n    {\r\n        Validate.notNull(realm, ""Realm must not be null"");\r\n        list = new WritableList(realm);\r\n        list.addListChangeListener(listChangeListener);\r\n        selectedList = new WritableList(realm);\r\n        selectedList.addListChangeListener(listChangeListener);\r\n    }\r\n\r\n    /**\r\n     * @return Returns the list.\r\n     */\r\n    public WritableList getList()\r\n    {\r\n        return list;\r\n    }\r\n\r\n    /**\r\n     * @return Returns the checkedList.\r\n     */\r\n    public WritableList getSelectedList()\r\n    {\r\n        return selectedList;\r\n    }\r\n\r\n    @Override\r\n    public String toString()\r\n    {\r\n        StringBuffer result = new StringBuffer();\r\n        result.append(""TableModel.list[\\n"");\r\n        for (Object element : list)\r\n        {\r\n            result.append(""  "" + element.toString() + ""\\n"");\r\n        }\r\n        result.append(""]\\nselectedList[\\n"");\r\n        for (Object element : selectedList)\r\n        {\r\n            result.append(""  "" + element.toString() + ""\\n"");\r\n        }\r\n        result.append(""]\\n\\n"");\r\n        return result.toString();\r\n    }\r\n\r\n}\r\n\r\n----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------\r\npackage com.startup.solynchron.actions;\n\nimport org.eclipse.jface.action.IAction;\nimport org.eclipse.jface.dialogs.MessageDialog;\nimport org.eclipse.jface.viewers.ISelection;\nimport org.eclipse.ui.IWorkbenchWindowActionDelegate;\n\nimport com.startup.solynchron.Activator;\nimport com.startup.solynchron.CodeExecutor;\nimport com.startup.solynchron.ExecutionManager;\nimport com.startup.solynchron.InitializationProgressException;\nimport com.startup.solynchron.dao.LogicManager;\nimport com.startup.solynchron.dao.RecordLogic;\n\n/**\n * Our sample action implements workbench action delegate.\n * The action proxy will be created by the workbench and\n * shown in the UI. When the user tries to use the action,\n * this delegate will be created and execution will be \n * delegated to it.\n * @see IWorkbenchWindowActionDelegate\n */\npublic class OpenProblemFormAction extends OpenFormEditorAction {\n    \n\t/**\n\t * The constructor.\n\t */\n\tpublic OpenProblemFormAction() {\n\t}\n\n\t/**\n\t * The action has been activated. The argument of the\n\t * method represents the 'real' action sitting\n\t * in the workbench UI.\n\t * @see IWorkbenchWindowActionDelegate#run\n\t */\n\tpublic void run(IAction action) {\n\t\ttry {\n\t\t\tObject count = ExecutionManager.executeInTransaction(\n\t\t\t\t\tnew CodeExecutor(""open"") {\n\t\t\t\t@Override\n\t\t\t\tpublic Object execute(Object[] params) throws Exception {\n\t\t\t\t\treturn newProblem();\n\t\t\t\t}\n\t\t\t}, null);\n\t\t\t\n\t\t\tif (count != null) {\n\t\t\t\tMessageDialog.openInformation(\n\t\t\t\t\tgetWindow().getShell(),\n\t    \t\t\t""Sample_derby Plug-in"",\n\t    \t\t\t""We have "" + count + \n\t\t\t\t\t"" records in the database"");\n\t\t\t}\n\t\t} catch (Exception ex) {\n\t\t\tMessageDialog.openError(\n\t    \t\t\tgetWindow().getShell(),\n\t    \t\t\t""Solynchron Plug-in Error"",\n\t    \t\t\t""Error occurred: "" + ex.getMessage());\n\t\t\tActivator.log(ex);\n\t\t}\n\t}\n\n\t/**\n\t * Selection in the workbench has been changed. We \n\t * can change the state of the 'real' action here\n\t * if we want, but this can only happen after \n\t * the delegate has been created.\n\t * @see IWorkbenchWindowActionDelegate#selectionChanged\n\t */\n\tpublic void selectionChanged(IAction action, ISelection selection) {\n\t\t\n\t}\n\n\t/**\n\t * We can use this method to dispose of any system\n\t * resources we previously allocated.\n\t * @see IWorkbenchWindowActionDelegate#dispose\n\t */\n\tpublic void dispose() {\n\t}\n\n\tprivate Object newProblem() throws InitializationProgressException {\n\t\tRecordLogic logic = (RecordLogic) LogicManager.get(LogicManager.RECORD_LOGIC);\n\t\tLong result = logic.incrementRecord();\n\t\tif (result != null) {\n\t\t\topenEditor(new FormEditorInput(\n\t\t\t\t\tActivator.getResource(""OpenProblemFormAction.name"")), \n\t\t\t\t\t""com.startup.solynchron.problem-editor""); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t}\n\t\treturn result;\n\t}\n\t\n}\r\n----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------\r\n/**mbTy\r\n * \r\n */\r\npackage com.startup.solynchron.forms;\r\n\r\nimport net.sf.rcpforms.bindingvalidation.ValidationManager;\r\nimport net.sf.rcpforms.bindingvalidation.forms.RCPFormPart;\r\nimport net.sf.rcpforms.modeladapter.converter.MethodValidator;\r\nimport net.sf.rcpforms.modeladapter.converter.SymmetricMultilineValidator;\r\nimport net.sf.rcpforms.widgetwrapper.builder.GridBuilder;\r\nimport net.sf.rcpforms.widgetwrapper.builder.GridLayoutFactory;\r\nimport net.sf.rcpforms.widgetwrapper.wrapper.EControlState;\r\nimport net.sf.rcpforms.widgetwrapper.wrapper.RCPCombo;\r\nimport net.sf.rcpforms.widgetwrapper.wrapper.RCPSection;\r\nimport net.sf.rcpforms.widgetwrapper.wrapper.RCPSimpleLabel;\r\nimport net.sf.rcpforms.widgetwrapper.wrapper.RCPSimpleText;\r\n\r\nimport org.eclipse.jface.viewers.Viewer;\r\nimport org.eclipse.swt.SWT;\r\nimport org.eclipse.swt.layout.GridData;\r\nimport org.eclipse.swt.widgets.Composite;\r\nimport org.eclipse.ui.forms.widgets.FormToolkit;\r\n\r\nimport com.startup.solynchron.Activator;\r\nimport com.startup.solynchron.obj.problem.Problem;\r\nimport com.startup.solynchron.obj.problem.ProblemType;\r\n\r\n/**\r\n * This form part is responsible for displaying and editing the most important\r\n * information of a problem.\r\n * \r\n * @author plamKaTa\r\n *\r\n */\r\npublic class ProblemFormPart extends RCPFormPart {\r\n\t\r\n\tprivate RCPSection mainSection;\r\n\t\r\n\tprivate RCPCombo cmbType;\r\n\t\r\n\tprivate RCPSimpleText txtDescription;\r\n\r\n\t/**\r\n\t * Constructor of a form part.\r\n\t */\r\n\tpublic ProblemFormPart() {\r\n\t}\r\n\t\r\n\t/* (non-Javadoc)\r\n\t * @see net.sf.rcpforms.bindingvalidation.forms.RCPFormPart#createUI(org.eclipse.ui.forms.widgets.FormToolkit, org.eclipse.swt.widgets.Composite)\r\n\t */\r\n\t@Override\r\n\tpublic void createUI(FormToolkit toolkit, Composite parent) {\r\n\t\tmainSection = new RCPSection(Activator.getResource(""ProblemView.title""));\r\n\t\t\r\n\t\tcmbType = new RCPCombo(Activator.getResource(""ProblemView.lblType""), false);\r\n\r\n\t\tRCPSimpleLabel lblDescription = new RCPSimpleLabel(\r\n\t\t\t\tActivator.getResource(""ProblemView.lblDescription""));\r\n\t\ttxtDescription = new RCPSimpleText(SWT.MULTI);\r\n\t\ttxtDescription.setState(EControlState.MANDATORY, true);\r\n\t\t\r\n\t\tGridBuilder builder = new GridBuilder(toolkit, parent, 2);\r\n\t\tGridBuilder widgetBuilder = builder.addContainer(mainSection, 4);\r\n\t\t\r\n\t\twidgetBuilder.addLine(cmbType);\r\n\t\t\r\n\t\twidgetBuilder.add(lblDescription);\r\n\t\t\r\n\t\tGridData gd = GridLayoutFactory.createDefaultLayoutData();\r\n\t\tgd.widthHint = widgetBuilder.getWidthHint(10);\r\n\t\tgd.horizontalSpan = 3;\r\n\t\tgd.grabExcessHorizontalSpace = true;\r\n\t\tgd.heightHint = widgetBuilder.getHeightHint(4);\r\n\t\tgd.verticalSpan = 3;\r\n\t\tgd.grabExcessVerticalSpace = true;\r\n\t\twidgetBuilder.add(txtDescription, gd);\r\n\t\twidgetBuilder.newLine();\r\n\t}\r\n\r\n\t/* (non-Javadoc)\r\n\t * @see net.sf.rcpforms.bindingvalidation.forms.RCPFormPart#bind(net.sf.rcpforms.bindingvalidation.ValidationManager, java.lang.Object)\r\n\t */\r\n\t@Override\r\n\tpublic void bind(ValidationManager bm, Object modelBean) {\r\n\t\tViewer cmbViewer = cmbType.getViewer();\r\n\t\t\r\n\t\tbm.bindValue(cmbType, modelBean, Problem.TYPE);\r\n\t\tbm.bindValue(txtDescription, modelBean, Problem.DESCRIPTION);\r\n\t\t\r\n\t\tMethodValidator txtValidator = new SymmetricMultilineValidator(Problem.DESCRIPTION, 5, 80);\r\n\t    bm.addValidator(this, txtValidator); \r\n\t}\r\n\r\n\t/* (non-Javadoc)\r\n\t * @see net.sf.rcpforms.bindingvalidation.forms.RCPFormPart#setState(net.sf.rcpforms.widgetwrapper.wrapper.EControlState, boolean)\r\n\t */\r\n\t@Override\r\n\tpublic void setState(EControlState state, boolean value) {\r\n        mainSection.setState(state, value);\r\n\t}\r\n\r\n}\r\n\r\n----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------\r\n/*******************************************************************************\r\n * This program and the accompanying materials\r\n * are made available under the terms of the Eclipse Public License v1.0\r\n * which accompanies this distribution, and is available at\r\n * http://www.eclipse.org/legal/epl-v10.html\r\n *\r\n * Contributors:\r\n *     Remo Loetscher - initial API and implementation\r\n *\r\n ******************************************************************************\r\n */\r\n\r\npackage net.sf.rcpforms.examples.complete;\r\n\r\nimport net.sf.rcpforms.bindingvalidation.ValidationManager;\r\nimport net.sf.rcpforms.bindingvalidation.forms.RCPFormFactory;\r\nimport net.sf.rcpforms.bindingvalidation.forms.RCPFormPart;\r\nimport net.sf.rcpforms.modeladapter.converter.MethodValidator;\r\nimport net.sf.rcpforms.modeladapter.converter.SymmetricMultilineValidator;\r\nimport net.sf.rcpforms.widgetwrapper.builder.GridBuilder;\r\nimport net.sf.rcpforms.widgetwrapper.builder.GridLayoutFactory;\r\nimport net.sf.rcpforms.widgetwrapper.customwidgets.RCPDatePicker;\r\nimport net.sf.rcpforms.widgetwrapper.wrapper.EControlState;\r\nimport net.sf.rcpforms.widgetwrapper.wrapper.RCPCombo;\r\nimport net.sf.rcpforms.widgetwrapper.wrapper.RCPSection;\r\nimport net.sf.rcpforms.widgetwrapper.wrapper.RCPSimpleButton;\r\nimport net.sf.rcpforms.widgetwrapper.wrapper.RCPSimpleLabel;\r\nimport net.sf.rcpforms.widgetwrapper.wrapper.RCPSimpleText;\r\nimport net.sf.rcpforms.widgetwrapper.wrapper.RCPText;\r\n\r\nimport org.eclipse.swt.SWT;\r\nimport org.eclipse.swt.layout.GridData;\r\nimport org.eclipse.swt.widgets.Composite;\r\nimport org.eclipse.ui.forms.widgets.FormToolkit;\r\n\r\n/**\r\n * FormPart for GridLayouts in sandbox example. Demonstrates some simple layouts.\r\n * \r\n * @author Remo Loetscher\r\n */\r\npublic class SandboxLayoutFormPart extends RCPFormPart\r\n{\r\n    private RCPSection mainSection;\r\n\r\n    private RCPSimpleText m_multiLineText;\r\n\r\n    private RCPSimpleLabel m_labelText;\r\n\r\n    private RCPDatePicker m_birthDateText;\r\n\r\n    private RCPCombo m_geschlechtCombo;\r\n\r\n    private RCPSimpleButton m_kontoueberzugCheck;\r\n\r\n    private RCPText m_singleLineText;\r\n\r\n    /**\r\n     * Constructor for KontodatenViewModel.\r\n     */\r\n    public SandboxLayoutFormPart()\r\n    {\r\n    }\r\n\r\n    public void createUI(FormToolkit toolkit, Composite parent)\r\n    {\r\n        // create wrappers\r\n        mainSection = new RCPSection(""LayoutSection"");\r\n        m_labelText = new RCPSimpleLabel(""Multiline:"");\r\n        m_multiLineText = new RCPSimpleText(SWT.MULTI);\r\n        m_multiLineText.setState(EControlState.MANDATORY, true);\r\n\r\n        m_singleLineText = new RCPText(""SingleLine:"");\r\n\r\n        m_birthDateText = new RCPDatePicker(""DatePicker:"");\r\n        m_birthDateText.setState(EControlState.RECOMMENDED, true);\r\n        m_geschlechtCombo = new RCPCombo(""Combo:"", false);\r\n        m_kontoueberzugCheck = new RCPSimpleButton(""CheckBox"", SWT.CHECK | SWT.RIGHT_TO_LEFT);\r\n\r\n        // build layout\r\n        GridBuilder builder = new GridBuilder(toolkit, parent, 2);\r\n        GridBuilder widgetBuilder = builder.addContainer(mainSection, 4);\r\n\r\n        widgetBuilder.add(m_labelText);\r\n\r\n        // build customised layout\r\n        GridData gd = GridLayoutFactory.createDefaultLayoutData();\r\n//        gd.horizontalAlignment = SWT.FILL;\r\n        gd.widthHint = widgetBuilder.getWidthHint(10);\r\n        gd.horizontalSpan = 3;\r\n        gd.grabExcessHorizontalSpace = true;\r\n//        gd.verticalAlignment = SWT.FILL;\r\n        gd.heightHint = widgetBuilder.getHeightHint(4);\r\n        gd.verticalSpan = 3;\r\n        gd.grabExcessVerticalSpace = true;\r\n        widgetBuilder.add(m_multiLineText, gd);\r\n\r\n        widgetBuilder.add(new RCPSimpleLabel(""Vertical Span: 2nd Line...""));\r\n        widgetBuilder.add(new RCPSimpleLabel(""Vertical Span: 3rd Line...""));\r\n        widgetBuilder.newLine();\r\n        // go ahead with ""normal"" layout.\r\n\r\n        // add empty lines\r\n        widgetBuilder.add(new RCPSimpleLabel(""Filler and empty line added...""));\r\n        widgetBuilder.fillLine();\r\n        widgetBuilder.newLine();\r\n\r\n        widgetBuilder.addLine(m_birthDateText, 8);\r\n        widgetBuilder.addSkipLeftLine(m_singleLineText, 1);\r\n        widgetBuilder.addLine(m_kontoueberzugCheck);\r\n        // create one radio button for each code and associate a radio group manager\r\n\r\n        widgetBuilder.addLine(m_geschlechtCombo);\r\n\r\n    }\r\n\r\n    public void bind(ValidationManager context, Object dataModel)\r\n    {\r\n        context.bindValue(m_multiLineText, dataModel, SimpleBean.P_TEXT);\r\n//        MethodValidator validator = new AsymmetricMultilineValidator(SimpleBean.P_TEXT, new int[]{1,2,3});\r\n        MethodValidator validator = new SymmetricMultilineValidator(SimpleBean.P_TEXT, 3, 35);\r\n        context.addValidator(this, validator); \r\n    }\r\n\r\n    @Override\r\n    public void setState(EControlState state, boolean value)\r\n    {\r\n        mainSection.setState(state, value);\r\n\r\n    }\r\n\r\n    public static void main(String[] args)\r\n    {\r\n\r\n        final Object model = new SimpleBean();\r\n        final RCPFormPart part = new SandboxLayoutFormPart();\r\n        RCPFormFactory.getInstance().startTestShell(""SandboxLayoutFormPart"", part, model);\r\n    }\r\n\r\n}\r\n\r\n----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------\r\npackage com.startup.solynchron.dao;\r\n\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\n\r\n/**\r\n * TODO: migrate logic instantiation to OSGI style instantiation\r\n * \r\n * @author plamKaTa\r\n *\r\n */\r\npublic class LogicManager<> {\r\n\t\r\n\tpublic static final String RECORD_LOGIC = ""record"";\r\n\t\r\n\tpublic static final String PROBLEM_LOGIC = ""problem"";\r\n\t\r\n\tprivate static Map<String, ILogic> logicRegistry = \r\n\t\tnew HashMap<String, ILogic>();\r\n\t\r\n\tstatic {\r\n\t\tregister(RECORD_LOGIC, new RecordLogic());\r\n\t\t\r\n\t}\r\n\t\r\n\tpublic static void register(String key, ILogic logic) {\r\n\t\tlogicRegistry.put(key, logic);\r\n\t}\r\n\t\r\n\tpublic static void deregister(String key) {\r\n\t\tlogicRegistry.remove(key);\r\n\t}\r\n\t\r\n\tpublic static T get(String key) {\r\n\t\treturn (T) logicRegistry.get(key);\r\n\t}\r\n\r\n}\r\n\r\n----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------",1254995269309
executed,command,org.eclipse.ui,3.5.1.M20090902-1000,"org.eclipse.ui.edit.delete",1254995269575
executed,command,org.eclipse.ui,3.5.1.M20090902-1000,"org.eclipse.ui.file.save",1254995271029
executed,command,org.eclipse.ui,3.5.1.M20090902-1000,"org.eclipse.ui.edit.text.contentAssist.proposals",1254995311786
executed,command,org.eclipse.ui,3.5.1.M20090902-1000,"org.eclipse.ui.file.save",1254995316425
activated,editor,org.eclipse.jdt.ui,3.5.1.r351_v20090821-0800,"org.eclipse.jdt.ui.CompilationUnitEditor",1254995343515
closed,editor,org.eclipse.jdt.ui,3.5.1.r351_v20090821-0800,"org.eclipse.jdt.ui.CompilationUnitEditor",1254995343515
activated,editor,org.eclipse.jdt.ui,3.5.1.r351_v20090821-0800,"org.eclipse.jdt.ui.CompilationUnitEditor",1254995371943
closed,editor,org.eclipse.jdt.ui,3.5.1.r351_v20090821-0800,"org.eclipse.jdt.ui.CompilationUnitEditor",1254995371943
activated,view,org.eclipse.jdt.ui,3.5.1.r351_v20090821-0800,"org.eclipse.jdt.ui.PackageExplorer",1254995381139
executed,command,org.eclipse.ui,3.5.1.M20090902-1000,"org.eclipse.ui.navigate.linkWithEditor",1254995381286
executed,command,org.eclipse.ui,3.5.1.M20090902-1000,"org.eclipse.ui.navigate.linkWithEditor",1254995381970
activated,editor,org.eclipse.jdt.ui,3.5.1.r351_v20090821-0800,"org.eclipse.jdt.ui.CompilationUnitEditor",1254995398824
activated,editor,org.eclipse.jdt.ui,3.5.1.r351_v20090821-0800,"org.eclipse.jdt.ui.CompilationUnitEditor",1254995404552
executed,command,org.eclipse.ui,3.5.1.M20090902-1000,"org.eclipse.ui.edit.copy",1254995406837
activated,editor,org.eclipse.jdt.ui,3.5.1.r351_v20090821-0800,"org.eclipse.jdt.ui.CompilationUnitEditor",1254995408725
executed,command,org.eclipse.ui,3.5.1.M20090902-1000,"org.eclipse.ui.edit.paste",1254995411555
executed,command,org.eclipse.ui,3.5.1.M20090902-1000,"org.eclipse.ui.edit.delete",1254995419870
executed,command,org.eclipse.ui,3.5.1.M20090902-1000,"org.eclipse.ui.edit.delete",1254995420042
executed,command,org.eclipse.ui,3.5.1.M20090902-1000,"org.eclipse.ui.edit.delete",1254995422960
executed,command,org.eclipse.ui,3.5.1.M20090902-1000,"org.eclipse.ui.edit.delete",1254995423115
executed,command,org.eclipse.ui,3.5.1.M20090902-1000,"org.eclipse.ui.file.save",1254995424149
executed,command,org.eclipse.ui,3.5.1.M20090902-1000,"org.eclipse.ui.edit.text.contentAssist.proposals",1254995446393
