what,kind,bundleId,bundleVersion,description,time
executed,command,org.eclipse.ui,3.5.1.M20090902-1000,"org.eclipse.ui.file.save",1254993530798
executed,command,org.eclipse.ui.workbench.texteditor,3.5.0.v20090603,"org.eclipse.ui.edit.text.goto.lineEnd",1254993535272
executed,command,org.eclipse.ui.workbench.texteditor,3.5.0.v20090603,"org.eclipse.ui.edit.text.goto.lineEnd",1254993535311
executed,command,org.eclipse.ui,3.5.1.M20090902-1000,"org.eclipse.ui.edit.delete",1254993537528
executed,command,org.eclipse.ui.workbench.texteditor,3.5.0.v20090603,"org.eclipse.ui.edit.text.goto.lineEnd",1254993542999
error,log,,,"All Source code being worked on:\r\n----------------------------------- SOURCE BEGIN -------------------------------------\r\n/**\r\n * \r\n */\r\npackage com.startup.solynchron.obj.domain;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\nimport javax.persistence.Basic;\r\nimport javax.persistence.CascadeType;\r\nimport javax.persistence.Column;\r\nimport javax.persistence.Entity;\r\nimport javax.persistence.FetchType;\r\nimport javax.persistence.ManyToOne;\r\nimport javax.persistence.OneToMany;\r\nimport javax.persistence.OrderBy;\r\n\r\nimport com.startup.solynchron.obj.ModelObject;\r\nimport com.startup.solynchron.obj.event.CompareManager;\r\n\r\n/**\r\n * @author plamKaTa\r\n *\r\n */\r\n@Entity\r\npublic class DomainCategory extends ModelObject {\r\n\t\r\n\t@Basic\r\n\t@Column(unique = true, nullable = false)\r\n\tprivate String name;\r\n\t\r\n\tprivate DomainCategory parent;\r\n\t\r\n\tprivate List<DomainCategory> children = new ArrayList<DomainCategory>();\r\n\t\r\n\tprivate List<Domain> domains = new ArrayList<Domain>();\r\n\r\n\t/**\r\n\t * \r\n\t */\r\n\tpublic DomainCategory() {\r\n\t\t// TODO Auto-generated constructor stub\r\n\t}\r\n\r\n\tpublic String getName() {\r\n\t\treturn name;\r\n\t}\r\n\r\n\tpublic void setName(String name) {\r\n\t\tthis.name = name;\r\n\t}\r\n\r\n\t@ManyToOne\r\n\tpublic DomainCategory getParent() {\r\n\t\treturn parent;\r\n\t}\r\n\r\n\tpublic void setParent(DomainCategory parent) {\r\n\t\tthis.parent = parent;\r\n\t}\r\n\r\n\t@OneToMany(mappedBy = ""parent"", cascade = {CascadeType.MERGE, CascadeType.PERSIST})\r\n\t@OrderBy(""name"")\r\n\tpublic List<DomainCategory> getChildren() {\r\n\t\treturn children;\r\n\t}\r\n\r\n\tpublic void setChildren(List<DomainCategory> children) {\r\n\t\tthis.children = children;\r\n\t}\r\n\r\n\t@OneToMany(mappedBy = ""category"", fetch = FetchType.LAZY)\r\n\tpublic List<Domain> getDomains() {\r\n\t\treturn domains;\r\n\t}\r\n\r\n\tpublic void setDomains(List<Domain> domains) {\r\n\t\tthis.domains = domains;\r\n\t}\r\n\t\r\n\tpublic boolean equalsParents(Object obj) {\r\n\t\tif (obj instanceof DomainCategory) {\r\n\t\t\tDomainCategory other = (DomainCategory) obj;\r\n\t\t\tboolean equal = CompareManager.equals(this.getParent(), other.getParent());\r\n\t\t\tif (this.getParent() == null || other.getParent() == null) {\r\n\t\t\t\treturn equal;\r\n\t\t\t}\r\n\t\t\tif (this.getParent().isNew() || other.getParent().isNew()) {\r\n\t\t\t\treturn this.getParent().equals(other.getParent());\r\n\t\t\t} else {\r\n\t\t\t\treturn equal;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic boolean equals(Object obj) {\r\n\t\tif (obj instanceof DomainCategory) {\r\n\t\t\tDomainCategory other = (DomainCategory) obj;\r\n\t\t\treturn CompareManager.equals(\r\n\t\t\t\t\tthis.getName(), other.getName()) && \r\n\t\t\t\t\t\tequalsParents(obj);\r\n\t\t\t\t\r\n\t\t\t\r\n\t\t} else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic int hashCode() {\r\n\t\tif (name != null && parent != null) {\r\n\t\t\treturn name.hashCode() @;\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\n----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------\r\n/**\r\n * \r\n */\r\npackage com.startup.solynchron.obj.domain;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\nimport javax.persistence.Basic;\r\nimport javax.persistence.CascadeType;\r\nimport javax.persistence.Column;\r\nimport javax.persistence.Entity;\r\nimport javax.persistence.FetchType;\r\nimport javax.persistence.ManyToOne;\r\nimport javax.persistence.OneToMany;\r\nimport javax.persistence.OrderBy;\r\n\r\nimport com.startup.solynchron.obj.ModelObject;\r\nimport com.startup.solynchron.obj.event.CompareManager;\r\n\r\n/**\r\n * @author plamKaTa\r\n *\r\n */\r\n@Entity\r\npublic class DomainCategory extends ModelObject {\r\n\t\r\n\t@Basic\r\n\t@Column(unique = true, nullable = false)\r\n\tprivate String name;\r\n\t\r\n\tprivate DomainCategory parent;\r\n\t\r\n\tprivate List<DomainCategory> children = new ArrayList<DomainCategory>();\r\n\t\r\n\tprivate List<Domain> domains = new ArrayList<Domain>();\r\n\r\n\t/**\r\n\t * \r\n\t */\r\n\tpublic DomainCategory() {\r\n\t\t// TODO Auto-generated constructor stub\r\n\t}\r\n\r\n\tpublic String getName() {\r\n\t\treturn name;\r\n\t}\r\n\r\n\tpublic void setName(String name) {\r\n\t\tthis.name = name;\r\n\t}\r\n\r\n\t@ManyToOne\r\n\tpublic DomainCategory getParent() {\r\n\t\treturn parent;\r\n\t}\r\n\r\n\tpublic void setParent(DomainCategory parent) {\r\n\t\tthis.parent = parent;\r\n\t}\r\n\r\n\t@OneToMany(mappedBy = ""parent"", cascade = {CascadeType.MERGE, CascadeType.PERSIST})\r\n\t@OrderBy(""name"")\r\n\tpublic List<DomainCategory> getChildren() {\r\n\t\treturn children;\r\n\t}\r\n\r\n\tpublic void setChildren(List<DomainCategory> children) {\r\n\t\tthis.children = children;\r\n\t}\r\n\r\n\t@OneToMany(mappedBy = ""category"", fetch = FetchType.LAZY)\r\n\tpublic List<Domain> getDomains() {\r\n\t\treturn domains;\r\n\t}\r\n\r\n\tpublic void setDomains(List<Domain> domains) {\r\n\t\tthis.domains = domains;\r\n\t}\r\n\t\r\n\tpublic boolean equalsParents(Object obj) {\r\n\t\tif (obj instanceof DomainCategory) {\r\n\t\t\tDomainCategory other = (DomainCategory) obj;\r\n\t\t\tboolean equal = CompareManager.equals(this.getParent(), other.getParent());\r\n\t\t\tif (this.getParent() == null || other.getParent() == null) {\r\n\t\t\t\treturn equal;\r\n\t\t\t}\r\n\t\t\tif (this.getParent().isNew() || other.getParent().isNew()) {\r\n\t\t\t\treturn this.getParent().equals(other.getParent());\r\n\t\t\t} else {\r\n\t\t\t\treturn equal;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic boolean equals(Object obj) {\r\n\t\tif (obj instanceof DomainCategory) {\r\n\t\t\tDomainCategory other = (DomainCategory) obj;\r\n\t\t\treturn CompareManager.equals(\r\n\t\t\t\t\tthis.getName(), other.getName()) && \r\n\t\t\t\t\t\tequalsParents(obj);\r\n\t\t\t\t\r\n\t\t\t\r\n\t\t} else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic int hashCode() {\r\n\t\tif (name != null && parent != null) {\r\n\t\t\treturn name.hashCode() @;\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\n----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------\r\n/*******************************************************************************\r\n * This program and the accompanying materials\r\n * are made available under the terms of the Eclipse Public License v1.0\r\n * which accompanies this distribution, and is available at\r\n * http://www.eclipse.org/legal/epl-v10.html\r\n *\r\n * Contributors:\r\n *     Marco van Meegen - initial API and implementation\r\n *\r\n ******************************************************************************\r\n */\r\n\r\npackage net.sf.rcpforms.examples.complete;\r\n\r\nimport java.util.Date;\r\n\r\nimport net.sf.rcpforms.bindingvalidation.ValidationManager;\r\nimport net.sf.rcpforms.bindingvalidation.forms.RCPFormFactory;\r\nimport net.sf.rcpforms.bindingvalidation.forms.RCPFormPart;\r\nimport net.sf.rcpforms.common.NullValue;\r\nimport net.sf.rcpforms.common.util.Validate;\r\nimport net.sf.rcpforms.examples.complete.TestModel.Gender;\r\nimport net.sf.rcpforms.modeladapter.tables.ObservableTreeListBeanContentProvider;\r\nimport net.sf.rcpforms.tablesupport.tables.ColumnConfiguration;\r\nimport net.sf.rcpforms.tablesupport.tables.ECellEditorType;\r\nimport net.sf.rcpforms.tablesupport.tables.TableUtil;\r\nimport net.sf.rcpforms.widgetwrapper.builder.GridBuilder;\r\nimport net.sf.rcpforms.widgetwrapper.builder.GridLayoutFactory;\r\nimport net.sf.rcpforms.widgetwrapper.wrapper.EControlState;\r\nimport net.sf.rcpforms.widgetwrapper.wrapper.RCPCheckboxTable;\r\nimport net.sf.rcpforms.widgetwrapper.wrapper.RCPComposite;\r\nimport net.sf.rcpforms.widgetwrapper.wrapper.RCPPushButton;\r\nimport net.sf.rcpforms.widgetwrapper.wrapper.RCPSection;\r\nimport net.sf.rcpforms.widgetwrapper.wrapper.RCPTable;\r\nimport net.sf.rcpforms.widgetwrapper.wrapper.RCPTree;\r\n\r\nimport org.eclipse.core.databinding.Binding;\r\nimport org.eclipse.core.databinding.observable.list.WritableList;\r\nimport org.eclipse.jface.databinding.swt.SWTObservables;\r\nimport org.eclipse.jface.viewers.ITreeContentProvider;\r\nimport org.eclipse.jface.viewers.TableViewer;\r\nimport org.eclipse.jface.viewers.TreeViewer;\r\nimport org.eclipse.jface.viewers.Viewer;\r\nimport org.eclipse.swt.SWT;\r\nimport org.eclipse.swt.events.SelectionAdapter;\r\nimport org.eclipse.swt.events.SelectionEvent;\r\nimport org.eclipse.swt.layout.GridData;\r\nimport org.eclipse.swt.widgets.Composite;\r\nimport org.eclipse.swt.widgets.Display;\r\nimport org.eclipse.ui.forms.widgets.FormToolkit;\r\n\r\n/**\r\n * Example part demonstrating the advanced table features of RCPForms.\r\n * <p>\r\n * <ul>\r\n * <li>creating an editable table just by configuring the column properties, no coding needed\r\n * <li>how converters from data binding are automatically used to render table data\r\n * <li>binding of multi selection state of a checkbox table to a list\r\n * <li>binding of multi selection state of a normal table to a list\r\n * <li>automatic creation of a table cursor if the table contains editable columns\r\n * <li>disabled rows if {@link RCPTableFormToolkit} is used\r\n * </ul>\r\n * \r\n * @author Marco van Meegen\r\n */\r\npublic class SandboxTablePart extends RCPFormPart\r\n{\r\n    private RCPSection mainSection;\r\n\r\n    private RCPCheckboxTable m_CheckboxTable;\r\n\r\n    private RCPTable m_Table;\r\n\r\n    private RCPTable m_TableCursorSupport;\r\n\r\n    private RCPPushButton m_addColumn;\r\n\r\n    private RCPPushButton m_removeColumn;\r\n\r\n    private RCPPushButton m_toggleIsSelectable;\r\n\r\n    private RCPPushButton m_removeInput;\r\n\r\n    private TableViewer m_CheckboxTableViewer;\r\n\r\n    private TableViewer m_TableViewer;\r\n\r\n    private TableViewer m_TableViewerCursorSupport;\r\n\r\n    private RCPTree m_TreeTable;\r\n\r\n    private RCPTree m_CheckboxTreeTable;\r\n\r\n    private TreeViewer m_TreeTableViewer;\r\n\r\n    private TreeViewer m_checkedTreeTableViewer;\r\n\r\n    private TableModel dataModel;\r\n\r\n    private Binding tableCheckBinding;\r\n\r\n    public SandboxTablePart()\r\n    {\r\n        m_addColumn = new RCPPushButton(""add item"");\r\n        m_removeColumn = new RCPPushButton(""remove item"");\r\n        m_toggleIsSelectable = new RCPPushButton(""toggle selectable"");\r\n        m_removeInput = new RCPPushButton(""replace data"");\r\n\r\n        m_CheckboxTable = new RCPCheckboxTable(""CheckboxTable:"");\r\n        m_Table = new RCPTable(""Table:"");\r\n        m_TableCursorSupport = new RCPTable(""Table with cursor support:"");\r\n\r\n        // m_TreeTable = new RCPTree(""TreeTable:"", SWT.FULL_SELECTION);\r\n        // m_CheckboxTreeTable = new RCPTree(""CheckboxTreeTable:"", SWT.FULL_SELECTION | SWT.CHECK);\r\n\r\n    }\r\n\r\n    private static ColumnConfiguration[] createColumnConfigurations(boolean editable)\r\n    {\r\n        // this configures the table with the attributes to display;\r\n        // automatic conversion will be applied using the standard data binding converters\r\n        // which are used in text fields too\r\n        Object[] values = new Object[Gender.values().length + 1];\r\n        // add null value\r\n        values[0] = NullValue.getInstance();\r\n        System.arraycopy(Gender.values(), 0, values, 1, values.length - 1);\r\n        ColumnConfiguration[] columnConfigurations = {\r\n                new ColumnConfiguration(""Name"", TestModel.P_Name, 100, SWT.LEFT, false,\r\n                        editable ? ECellEditorType.TEXT : null).setGrabHorizontal(true),\r\n                new ColumnConfiguration(""Geburtsdatum"", TestModel.P_BirthDate, 80, SWT.LEFT, false,\r\n                        editable ? ECellEditorType.DATE : null),\r\n                editable ? new ColumnConfiguration(""Geschlecht"", TestModel.P_Gender, 60, SWT.LEFT,\r\n                        values) : new ColumnConfiguration(""Geschlecht"", TestModel.P_Gender, 60,\r\n                        SWT.LEFT),\r\n                new ColumnConfiguration(""Kontoüberzug"", TestModel.P_OverdrawAccount, 50,\r\n                        SWT.CENTER, false, editable ? ECellEditorType.CHECK : null),\r\n                new ColumnConfiguration(""Kinder"", TestModel.P_ChildCount, 50, SWT.RIGHT, false,\r\n                        editable ? ECellEditorType.TEXT : null),\r\n                new ColumnConfiguration(""Kontostand"", TestModel.P_AccountBalance, 70, SWT.RIGHT,\r\n                        false, editable ? ECellEditorType.TEXT : null)};\r\n        Validate.noNullElements(columnConfigurations,\r\n                ""ColumnConfigurations must not have null elements"");\r\n        return columnConfigurations;\r\n    }\r\n\r\n    @Override\r\n    public void createUI(FormToolkit formToolkit, Composite parent)\r\n    {\r\n        GridBuilder builder = new GridBuilder(formToolkit, parent, 1);\r\n        mainSection = new RCPSection(""Sandbox Table Section"");\r\n        GridBuilder sectionBuilder = builder.addContainer(mainSection, 2);\r\n        RCPComposite buttonPanel = new RCPComposite();\r\n        GridBuilder buttonWidgetFactory = sectionBuilder.fill(1).addContainer(buttonPanel, 8);\r\n        buttonWidgetFactory.add(m_addColumn);\r\n        m_addColumn.getSWTButton().addSelectionListener(new SelectionAdapter()\r\n        {\r\n            @Override\r\n            public void widgetSelected(SelectionEvent e)\r\n            {\r\n                addRandomItem();\r\n            }\r\n        });\r\n\r\n        buttonWidgetFactory.add(m_removeColumn);\r\n        m_removeColumn.getSWTButton().addSelectionListener(new SelectionAdapter()\r\n        {\r\n            @Override\r\n            public void widgetSelected(SelectionEvent e)\r\n            {\r\n                removeFirstItem();\r\n            }\r\n        });\r\n\r\n        buttonWidgetFactory.add(m_toggleIsSelectable);\r\n        m_toggleIsSelectable.getSWTButton().addSelectionListener(new SelectionAdapter()\r\n        {\r\n            @Override\r\n            public void widgetSelected(SelectionEvent e)\r\n            {\r\n                toggleSelectableState();\r\n            }\r\n        });\r\n        m_toggleIsSelectable.getSWTButton().setToolTipText(\r\n                ""removes all selections and toggle selectable state"");\r\n\r\n        buttonWidgetFactory.add(m_removeInput);\r\n        m_removeInput.getSWTButton().addSelectionListener(new SelectionAdapter()\r\n        {\r\n            @Override\r\n            public void widgetSelected(SelectionEvent e)\r\n            {\r\n                removeList();\r\n            }\r\n        });\r\n        m_removeInput.getSWTButton().setToolTipText(""replaces the list of the second table"");\r\n\r\n        // create normal Table with table cursor support\r\n        sectionBuilder.add(m_TableCursorSupport);\r\n        m_TableViewerCursorSupport = TableUtil.configureTableViewer(\r\n                (TableViewer) m_TableCursorSupport.getViewer(), createColumnConfigurations(true),\r\n                TestModel.class, false, true);\r\n\r\n        // create normal Table\r\n        sectionBuilder.add(m_Table);\r\n        m_TableViewer = TableUtil.configureTableViewer((TableViewer) m_Table.getViewer(),\r\n                createColumnConfigurations(true), TestModel.class, false, false);\r\n\r\n        // create Checkbox Table\r\n        sectionBuilder.add(m_CheckboxTable);\r\n        GridData gd = GridLayoutFactory.createDefaultLayoutData();\r\n        gd.grabExcessHorizontalSpace = true;\r\n        gd.grabExcessVerticalSpace = true;\r\n        gd.horizontalAlignment = SWT.FILL;\r\n//        gd.verticalIndent = SWT.FILL;\r\n        //show 3 columns with data and the header column\r\n        gd.heightHint = sectionBuilder.getHeightHint(3);\r\n        gd.heightHint += m_CheckboxTable.getSWTTable().getHeaderHeight();\r\n        \r\n        m_CheckboxTable.getSWTTable().setLayoutData(gd);\r\n        ColumnConfiguration[] columnConfigurations = createColumnConfigurations(false);\r\n        columnConfigurations[0].enableColumnSorting(false);\r\n        columnConfigurations[2].enableColumnSorting(false);\r\n        m_CheckboxTableViewer = TableUtil.configureTableViewer((TableViewer) m_CheckboxTable\r\n                .getViewer(), columnConfigurations, TestModel.class, false, false);\r\n\r\n        // create table tree\r\n        // sectionBuilder.add(m_TreeTable);\r\n        // class SampleObservableTreeListBeanContentProvider extends\r\n        // ObservableTreeListBeanContentProvider{\r\n        //            \r\n        // public Object[] getChildren(Object parentElement)\r\n        // {\r\n        // return new Object[]{generateNewDataModelItem(), generateNewDataModelItem()};\r\n        // }\r\n        //\r\n        // public Object getParent(Object element)\r\n        // {\r\n        // return null;\r\n        // }\r\n        //\r\n        // public boolean hasChildren(Object element)\r\n        // {\r\n        // return ((TestModel) element).getName().equals(""Mueller"");\r\n        // }\r\n        //\r\n        // public Object[] getElements(Object inputElement)\r\n        // {\r\n        // return dataModel.getList().toArray();\r\n        // }\r\n        //\r\n        // public void dispose()\r\n        // {\r\n        // }\r\n        // };\r\n        // m_TreeTableViewer =\r\n        // TableUtil.configureTreeTableViewer((TreeViewer)m_TreeTable.getViewer(),\r\n        // (ITreeContentProvider)new SampleObservableTreeListBeanContentProvider(),\r\n        // createColumnConfigurations(true), TestModel.class, false);\r\n        //        \r\n        // //create checked table tree\r\n        // sectionBuilder.add(m_CheckboxTreeTable);\r\n        // m_checkedTreeTableViewer =\r\n        // TableUtil.configureTreeTableViewer((TreeViewer)m_CheckboxTreeTable.getViewer(),\r\n        // (ITreeContentProvider)new SampleObservableTreeListBeanContentProvider(),\r\n        // createColumnConfigurations(false), TestModel.class, false);\r\n\r\n    }\r\n\r\n    @Override\r\n    public void bind(ValidationManager context, Object modelBean)\r\n    {\r\n        Validate.isTrue(modelBean instanceof TableModel);\r\n        this.dataModel = (TableModel) modelBean;\r\n\r\n        // set normal table viewers input\r\n        m_TableViewerCursorSupport.setInput(dataModel.getList());\r\n        m_TableViewer.setInput(dataModel.getList());\r\n        // bind selection to table; if its checkbox table, the check state is bound,\r\n        // otherwise the multi selection of rows.\r\n        context.bindSelection(m_TableCursorSupport, dataModel.getSelectedList());\r\n        tableCheckBinding = context.bindSelection(m_Table, dataModel.getSelectedList());\r\n\r\n        // set the CheckboxViewer's input\r\n        m_CheckboxTableViewer.setInput(dataModel.getList());\r\n\r\n        // bind selection to table; if its checkbox table, the check state is bound,\r\n        // otherwise the multi selection of rows.\r\n        context.bindSelection(m_CheckboxTable, dataModel.getSelectedList());\r\n\r\n        // set the TreeViewer's input\r\n        // m_TreeTableViewer.setInput(dataModel.getList());\r\n        // m_checkedTreeTableViewer.setInput(dataModel.getList());\r\n\r\n    }\r\n\r\n    private void removeFirstItem()\r\n    {\r\n        if (dataModel.getList().size() > 0)\r\n        {\r\n            dataModel.getList().remove(m_CheckboxTableViewer.getElementAt(0));\r\n        }\r\n    }\r\n\r\n    private void addRandomItem()\r\n    {\r\n        dataModel.getList().add(this.generateNewDataModelItem());\r\n    }\r\n\r\n    private TestModel generateNewDataModelItem()\r\n    {\r\n        // generate Geschlechtscode\r\n        Gender geschlecht = null;\r\n        switch ((int) (Math.random() * 10000) % 3)\r\n        {\r\n            case 0:\r\n                geschlecht = Gender.FEMALE;\r\n                break;\r\n            case 1:\r\n                geschlecht = Gender.MALE;\r\n                break;\r\n            default:\r\n                geschlecht = Gender.UNKNOWN;\r\n                break;\r\n        }\r\n\r\n        return new TestModel(""Mueller - "" + (int) (Math.random() * 1000), new Date((long) (Math\r\n                .random() * 1100000000000L)), (int) (Math.random() * 1000) % 2 == 0 ? true : false,\r\n                (int) (Math.random() * 1000) % 5, Math.random() * 10000, geschlecht, (int) (Math\r\n                        .random() * 1000) % 2 == 0 ? true : false);\r\n    }\r\n\r\n    private void toggleSelectableState()\r\n    {\r\n        // clear all selections\r\n        WritableList wl = dataModel.getList();\r\n        for (int i = 0; i < wl.size(); ++i)\r\n        {\r\n            TestModel s2dm = (TestModel) wl.get(i);\r\n            s2dm.setIsSelectable(s2dm.getIsSelectable() ? false : true);\r\n        }\r\n\r\n        // Problem -> fires no event... manual refresh...\r\n        m_TableViewerCursorSupport.refresh(true, true);\r\n        m_CheckboxTableViewer.refresh(true, true);\r\n        m_TableViewer.refresh(true, true);\r\n    }\r\n\r\n    private void removeList()\r\n    {\r\n        // unbind checkedList from table\r\n        if (tableCheckBinding != null)\r\n        {\r\n            tableCheckBinding.dispose();\r\n            tableCheckBinding = null;\r\n        }\r\n\r\n        // m_TableViewer.setInput(null);\r\n        WritableList newList = new WritableList(SWTObservables.getRealm(Display.getDefault()));\r\n        for (int i = 0; i < 10; ++i)\r\n        {\r\n            newList.add(this.generateNewDataModelItem());\r\n        }\r\n        m_TableViewer.setInput(newList);\r\n    }\r\n\r\n    public static void main(String[] args)\r\n    {\r\n        final TableModel model = new TableModel();\r\n        final RCPFormPart part = new SandboxTablePart();\r\n        RCPFormFactory.getInstance().startTestShell(""SandboxTablePart"", part, model);\r\n    }\r\n\r\n    @Override\r\n    public void setState(EControlState state, boolean value)\r\n    {\r\n        mainSection.setState(state, value);\r\n\r\n    }\r\n}\r\n\r\n----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------\r\n/**\r\n * \r\n */\r\npackage com.startup.solynchron.obj.domain;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\nimport javax.persistence.CascadeType;\r\nimport javax.persistence.Entity;\r\nimport javax.persistence.ManyToOne;\r\nimport javax.persistence.OneToMany;\r\nimport javax.persistence.OrderBy;\r\n\r\nimport com.damnhandy.aspects.bean.Observable;\r\nimport com.startup.solynchron.obj.ModelObject;\r\n\r\n/**\r\n * @author plamKaTa\r\n *\r\n */\r\n@Observable\r\n@Entity\r\npublic class Domain extends ModelObject {\r\n\t\r\n\tpublic static final String DESCRIPTION = ""description"";\r\n\t\r\n\tpublic static final String CATEGORY = ""category"";\r\n\t\r\n\tpublic static final String TOOLS = ""tools"";\r\n\t\r\n\r\n\tprivate String description;\r\n\t\r\n\tprivate DomainCategory category;\r\n\t\r\n\tprivate List<DomainTool> tools = new ArrayList<DomainTool>();\r\n\t\r\n\t/**\r\n\t * \r\n\t */\r\n\tpublic Domain() {\r\n\t\tsuper();\r\n\t}\r\n\r\n\t\r\n\tpublic String getDescription() {\r\n\t\treturn description;\r\n\t}\r\n\r\n\tpublic void setDescription(String description) {\r\n\t\tthis.description = description;\r\n\t}\r\n\r\n\t@ManyToOne\r\n\tpublic DomainCategory getCategory() {\r\n\t\treturn category;\r\n\t}\r\n\r\n\tpublic void setCategory(DomainCategory category) {\r\n\t\tthis.category = category;\r\n\t}\r\n\r\n\r\n\t@OneToMany(mappedBy = ""domain"", cascade = {CascadeType.PERSIST, CascadeType.MERGE})\r\n\t@OrderBy(""tool, toolVersion"")\r\n\tpublic List<DomainTool> getTools() {\r\n\t\treturn tools;\r\n\t}\r\n\r\n\tpublic void setTools(List<DomainTool> tools) {\r\n\t\tthis.tools = tools;\r\n\t}\r\n\r\n}\r\n\r\n----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------\r\n/*******************************************************************************\r\n * This program and the accompanying materials\r\n * are made available under the terms of the Eclipse Public License v1.0\r\n * which accompanies this distribution, and is available at\r\n * http://www.eclipse.org/legal/epl-v10.html\r\n *\r\n * Contributors:\r\n *     Marco van Meegen - initial API and implementation\r\n *\r\n ******************************************************************************\r\n */\r\n\r\npackage net.sf.rcpforms.examples.complete;\r\n\r\nimport java.util.Arrays;\r\nimport java.util.Date;\r\n\r\nimport net.sf.rcpforms.common.util.Validate;\r\nimport net.sf.rcpforms.examples.complete.TestModel.Gender;\r\n\r\nimport org.eclipse.core.databinding.observable.Realm;\r\nimport org.eclipse.core.databinding.observable.list.IListChangeListener;\r\nimport org.eclipse.core.databinding.observable.list.ListChangeEvent;\r\nimport org.eclipse.core.databinding.observable.list.WritableList;\r\nimport org.eclipse.jface.databinding.swt.SWTObservables;\r\nimport org.eclipse.swt.widgets.Display;\r\n\r\nimport com.damnhandy.aspects.bean.Observable;\r\n\r\n/**\r\n * Class TableModel represents the presentation model for the table part. WritableList is used,\r\n * since notification is built-in and much more efficient than bean indexed property notification.\r\n * \r\n * @author Marco van Meegen\r\n * @author Remo Loetscher\r\n */\r\n@Observable\r\npublic class TableModel \r\n{\r\n\r\n    public static final String P_DIRTY = ""dirty"";\r\n    public static final String P_TEST_MODEL = ""testModel"";\r\n\r\n    IListChangeListener listChangeListener = new IListChangeListener()\r\n    {\r\n\r\n        public void handleListChange(ListChangeEvent event)\r\n        {\r\n            // not interested in which kind of change,\r\n            // only that it was changed!\r\n            firePropertyChange(TableModel.P_DIRTY, null, null);\r\n        }\r\n    };\r\n\r\n    /** list of elements to display in the table */\r\n    private WritableList list;\r\n\r\n    /** list of elements which are checked/selected in the table */\r\n    private WritableList selectedList;\r\n    \r\n    /** variable used for master detail binding and therefore it has to be initalised, not null! */\r\n    private TestModel testModel = new TestModel();\r\n\r\n    public TableModel()\r\n    {\r\n        this(SWTObservables.getRealm(Display.getDefault()));\r\n        TestModel[] list = {\r\n                new TestModel(""Mueller"", new Date(10000000000L), true, 0, 1000.0, Gender.UNKNOWN, true),\r\n                new TestModel(""Meier1"", new Date(20000000000L), false, 2, 500.0, Gender.MALE, true),\r\n                new TestModel(""Meier2"", new Date(100000000000L), false, 2, 123.0, Gender.FEMALE, false),\r\n                new TestModel(""Meier3"", new Date(40000000000L), false, 2, 11000.0, Gender.UNKNOWN, true),\r\n                new TestModel(""Meier4"", new Date(30000000000L), false, 2, 2.0, Gender.UNKNOWN, false)};\r\n        this.list.addAll(Arrays.asList(list));\r\n    }\r\n    \r\n    public TestModel getTestModel()\r\n    {\r\n        return testModel;\r\n    }\r\n    \r\n    public void setTestModel(TestModel newModel)\r\n    {\r\n        testModel = newModel;\r\n    }\r\n\r\n    /**\r\n     * create writable lists using given realm\r\n     */\r\n    public TableModel(Realm realm)\r\n    {\r\n        Validate.notNull(realm, ""Realm must not be null"");\r\n        list = new WritableList(realm);\r\n        list.addListChangeListener(listChangeListener);\r\n        selectedList = new WritableList(realm);\r\n        selectedList.addListChangeListener(listChangeListener);\r\n    }\r\n\r\n    /**\r\n     * @return Returns the list.\r\n     */\r\n    public WritableList getList()\r\n    {\r\n        return list;\r\n    }\r\n\r\n    /**\r\n     * @return Returns the checkedList.\r\n     */\r\n    public WritableList getSelectedList()\r\n    {\r\n        return selectedList;\r\n    }\r\n\r\n    @Override\r\n    public String toString()\r\n    {\r\n        StringBuffer result = new StringBuffer();\r\n        result.append(""TableModel.list[\\n"");\r\n        for (Object element : list)\r\n        {\r\n            result.append(""  "" + element.toString() + ""\\n"");\r\n        }\r\n        result.append(""]\\nselectedList[\\n"");\r\n        for (Object element : selectedList)\r\n        {\r\n            result.append(""  "" + element.toString() + ""\\n"");\r\n        }\r\n        result.append(""]\\n\\n"");\r\n        return result.toString();\r\n    }\r\n\r\n}\r\n\r\n----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------\r\n/**\r\n * \r\n */\r\npackage com.startup.solynchron.obj.problem;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\nimport javax.persistence.CascadeType;\r\nimport javax.persistence.Entity;\r\nimport javax.persistence.FetchType;\r\nimport javax.persistence.ManyToOne;\r\nimport javax.persistence.OneToMany;\r\nimport javax.persistence.OrderBy;\r\n\r\nimport com.damnhandy.aspects.bean.Nested;\r\nimport com.damnhandy.aspects.bean.Observable;\r\nimport com.startup.solynchron.obj.ModelObject;\r\nimport com.startup.solynchron.obj.domain.Domain;\r\nimport com.startup.solynchron.obj.solution.Solution;\r\n\r\n/**\r\n * @author plamKaTa\r\n *\r\n */\r\n@Observable\r\n@Entity\r\npublic class Problem extends ModelObject {\r\n\t\r\n\tpublic static final String DESCRIPTION = ""description"";\r\n\t\r\n\tpublic static final String TYPE = ""type"";\r\n\t\r\n\tpublic static final String DOMAIN = ""domain"";\r\n\t\r\n\tpublic static final String SOLUTIONS = ""solutions"";\r\n\t\r\n\tpublic static final String ARTIFACTS = ""artifacts"";\r\n\t\r\n\r\n\tprivate String description;\r\n\t\r\n\tprivate ProblemType type;\r\n\t\r\n\tprivate Domain domain;\r\n\t\r\n\tprivate List<Solution> solutions = new ArrayList<Solution>();\r\n\t\r\n\tprivate List<ProblemArtifact> artifacts = new ArrayList<ProblemArtifact>();\r\n\t\r\n\t/**\r\n\t * \r\n\t */\r\n\tpublic Problem() {\r\n\t\t// TODO Auto-generated constructor stub\r\n\t}\r\n\r\n\tpublic String getDescription() {\r\n\t\treturn description;\r\n\t}\r\n\r\n\tpublic void setDescription(String description) {\r\n\t\tthis.description = description;\r\n\t}\r\n\r\n\t@Nested\r\n\t@ManyToOne\r\n\tpublic ProblemType getType() {\r\n\t\treturn type;\r\n\t}\r\n\r\n\tpublic void setType(ProblemType type) {\r\n\t\tthis.type = type;\r\n\t}\r\n\r\n\t@ManyToOne(cascade = {CascadeType.PERSIST, CascadeType.MERGE})\r\n\tpublic Domain getDomain() {\r\n\t\treturn domain;\r\n\t}\r\n\r\n\tpublic void setDomain(Domain domain) {\r\n\t\tthis.domain = domain;\r\n\t}\r\n\r\n\t@OneToMany(mappedBy = ""problem"", \r\n\t\t\tcascade = {CascadeType.PERSIST, CascadeType.MERGE}, \r\n\t\t\tfetch = FetchType.LAZY)\r\n\t@OrderBy(""method"")\r\n\tpublic List<Solution> getSolutions() {\r\n\t\treturn solutions;\r\n\t}\r\n\r\n\tpublic void setSolutions(List<Solution> solutions) {\r\n\t\tthis.solutions = solutions;\r\n\t}\r\n\r\n\t@OneToMany(mappedBy = ""problem"", \r\n\t\t\tcascade = {CascadeType.MERGE, CascadeType.PERSIST}, \r\n\t\t\tfetch = FetchType.EAGER)\r\n\tpublic List<ProblemArtifact> getArtifacts() {\r\n\t\treturn artifacts;\r\n\t}\r\n\r\n\tpublic void setArtifacts(List<ProblemArtifact> artifacts) {\r\n\t\tthis.artifacts = artifacts;\r\n\t}\r\n\r\n}\r\n\r\n----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------\r\n/**mbTy\r\n * \r\n */\r\npackage com.startup.solynchron.forms;\r\n\r\nimport net.sf.rcpforms.bindingvalidation.ValidationManager;\r\nimport net.sf.rcpforms.bindingvalidation.forms.RCPFormPart;\r\nimport net.sf.rcpforms.modeladapter.converter.MethodValidator;\r\nimport net.sf.rcpforms.modeladapter.converter.SymmetricMultilineValidator;\r\nimport net.sf.rcpforms.widgetwrapper.builder.GridBuilder;\r\nimport net.sf.rcpforms.widgetwrapper.builder.GridLayoutFactory;\r\nimport net.sf.rcpforms.widgetwrapper.wrapper.EControlState;\r\nimport net.sf.rcpforms.widgetwrapper.wrapper.RCPCombo;\r\nimport net.sf.rcpforms.widgetwrapper.wrapper.RCPSection;\r\nimport net.sf.rcpforms.widgetwrapper.wrapper.RCPSimpleLabel;\r\nimport net.sf.rcpforms.widgetwrapper.wrapper.RCPSimpleText;\r\n\r\nimport org.eclipse.jface.viewers.Viewer;\r\nimport org.eclipse.swt.SWT;\r\nimport org.eclipse.swt.layout.GridData;\r\nimport org.eclipse.swt.widgets.Composite;\r\nimport org.eclipse.ui.forms.widgets.FormToolkit;\r\n\r\nimport com.startup.solynchron.Activator;\r\nimport com.startup.solynchron.obj.problem.Problem;\r\nimport com.startup.solynchron.obj.problem.ProblemType;\r\n\r\n/**\r\n * This form part is responsible for displaying and editing the most important\r\n * information of a problem.\r\n * \r\n * @author plamKaTa\r\n *\r\n */\r\npublic class ProblemFormPart extends RCPFormPart {\r\n\t\r\n\tprivate RCPSection mainSection;\r\n\t\r\n\tprivate RCPCombo cmbType;\r\n\t\r\n\tprivate RCPSimpleText txtDescription;\r\n\r\n\t/**\r\n\t * Constructor of a form part.\r\n\t */\r\n\tpublic ProblemFormPart() {\r\n\t}\r\n\t\r\n\t/* (non-Javadoc)\r\n\t * @see net.sf.rcpforms.bindingvalidation.forms.RCPFormPart#createUI(org.eclipse.ui.forms.widgets.FormToolkit, org.eclipse.swt.widgets.Composite)\r\n\t */\r\n\t@Override\r\n\tpublic void createUI(FormToolkit toolkit, Composite parent) {\r\n\t\tmainSection = new RCPSection(Activator.getResource(""ProblemView.title""));\r\n\t\t\r\n\t\tcmbType = new RCPCombo(Activator.getResource(""ProblemView.lblType""), false);\r\n\r\n\t\tRCPSimpleLabel lblDescription = new RCPSimpleLabel(\r\n\t\t\t\tActivator.getResource(""ProblemView.lblDescription""));\r\n\t\ttxtDescription = new RCPSimpleText(SWT.MULTI);\r\n\t\ttxtDescription.setState(EControlState.MANDATORY, true);\r\n\t\t\r\n\t\tGridBuilder builder = new GridBuilder(toolkit, parent, 2);\r\n\t\tGridBuilder widgetBuilder = builder.addContainer(mainSection, 4);\r\n\t\t\r\n\t\twidgetBuilder.addLine(cmbType);\r\n\t\t\r\n\t\twidgetBuilder.add(lblDescription);\r\n\t\t\r\n\t\tGridData gd = GridLayoutFactory.createDefaultLayoutData();\r\n\t\tgd.widthHint = widgetBuilder.getWidthHint(10);\r\n\t\tgd.horizontalSpan = 3;\r\n\t\tgd.grabExcessHorizontalSpace = true;\r\n\t\tgd.heightHint = widgetBuilder.getHeightHint(4);\r\n\t\tgd.verticalSpan = 3;\r\n\t\tgd.grabExcessVerticalSpace = true;\r\n\t\twidgetBuilder.add(txtDescription, gd);\r\n\t\twidgetBuilder.newLine();\r\n\t}\r\n\r\n\t/* (non-Javadoc)\r\n\t * @see net.sf.rcpforms.bindingvalidation.forms.RCPFormPart#bind(net.sf.rcpforms.bindingvalidation.ValidationManager, java.lang.Object)\r\n\t */\r\n\t@Override\r\n\tpublic void bind(ValidationManager bm, Object modelBean) {\r\n\t\tViewer cmbViewer = cmbType.getViewer();\r\n\t\t\r\n\t\tbm.bindValue(cmbType, modelBean, Problem.TYPE);\r\n\t\tbm.bindValue(txtDescription, modelBean, Problem.DESCRIPTION);\r\n\t\t\r\n\t\tMethodValidator txtValidator = new SymmetricMultilineValidator(Problem.DESCRIPTION, 5, 80);\r\n\t    bm.addValidator(this, txtValidator); \r\n\t}\r\n\r\n\t/* (non-Javadoc)\r\n\t * @see net.sf.rcpforms.bindingvalidation.forms.RCPFormPart#setState(net.sf.rcpforms.widgetwrapper.wrapper.EControlState, boolean)\r\n\t */\r\n\t@Override\r\n\tpublic void setState(EControlState state, boolean value) {\r\n        mainSection.setState(state, value);\r\n\t}\r\n\r\n}\r\n\r\n----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------\r\n/*******************************************************************************\r\n * This program and the accompanying materials\r\n * are made available under the terms of the Eclipse Public License v1.0\r\n * which accompanies this distribution, and is available at\r\n * http://www.eclipse.org/legal/epl-v10.html\r\n *\r\n * Contributors:\r\n *     Remo Loetscher - initial API and implementation\r\n *\r\n ******************************************************************************\r\n */\r\n\r\npackage net.sf.rcpforms.examples.complete;\r\n\r\nimport net.sf.rcpforms.bindingvalidation.ValidationManager;\r\nimport net.sf.rcpforms.bindingvalidation.forms.RCPFormFactory;\r\nimport net.sf.rcpforms.bindingvalidation.forms.RCPFormPart;\r\nimport net.sf.rcpforms.modeladapter.converter.MethodValidator;\r\nimport net.sf.rcpforms.modeladapter.converter.SymmetricMultilineValidator;\r\nimport net.sf.rcpforms.widgetwrapper.builder.GridBuilder;\r\nimport net.sf.rcpforms.widgetwrapper.builder.GridLayoutFactory;\r\nimport net.sf.rcpforms.widgetwrapper.customwidgets.RCPDatePicker;\r\nimport net.sf.rcpforms.widgetwrapper.wrapper.EControlState;\r\nimport net.sf.rcpforms.widgetwrapper.wrapper.RCPCombo;\r\nimport net.sf.rcpforms.widgetwrapper.wrapper.RCPSection;\r\nimport net.sf.rcpforms.widgetwrapper.wrapper.RCPSimpleButton;\r\nimport net.sf.rcpforms.widgetwrapper.wrapper.RCPSimpleLabel;\r\nimport net.sf.rcpforms.widgetwrapper.wrapper.RCPSimpleText;\r\nimport net.sf.rcpforms.widgetwrapper.wrapper.RCPText;\r\n\r\nimport org.eclipse.swt.SWT;\r\nimport org.eclipse.swt.layout.GridData;\r\nimport org.eclipse.swt.widgets.Composite;\r\nimport org.eclipse.ui.forms.widgets.FormToolkit;\r\n\r\n/**\r\n * FormPart for GridLayouts in sandbox example. Demonstrates some simple layouts.\r\n * \r\n * @author Remo Loetscher\r\n */\r\npublic class SandboxLayoutFormPart extends RCPFormPart\r\n{\r\n    private RCPSection mainSection;\r\n\r\n    private RCPSimpleText m_multiLineText;\r\n\r\n    private RCPSimpleLabel m_labelText;\r\n\r\n    private RCPDatePicker m_birthDateText;\r\n\r\n    private RCPCombo m_geschlechtCombo;\r\n\r\n    private RCPSimpleButton m_kontoueberzugCheck;\r\n\r\n    private RCPText m_singleLineText;\r\n\r\n    /**\r\n     * Constructor for KontodatenViewModel.\r\n     */\r\n    public SandboxLayoutFormPart()\r\n    {\r\n    }\r\n\r\n    public void createUI(FormToolkit toolkit, Composite parent)\r\n    {\r\n        // create wrappers\r\n        mainSection = new RCPSection(""LayoutSection"");\r\n        m_labelText = new RCPSimpleLabel(""Multiline:"");\r\n        m_multiLineText = new RCPSimpleText(SWT.MULTI);\r\n        m_multiLineText.setState(EControlState.MANDATORY, true);\r\n\r\n        m_singleLineText = new RCPText(""SingleLine:"");\r\n\r\n        m_birthDateText = new RCPDatePicker(""DatePicker:"");\r\n        m_birthDateText.setState(EControlState.RECOMMENDED, true);\r\n        m_geschlechtCombo = new RCPCombo(""Combo:"", false);\r\n        m_kontoueberzugCheck = new RCPSimpleButton(""CheckBox"", SWT.CHECK | SWT.RIGHT_TO_LEFT);\r\n\r\n        // build layout\r\n        GridBuilder builder = new GridBuilder(toolkit, parent, 2);\r\n        GridBuilder widgetBuilder = builder.addContainer(mainSection, 4);\r\n\r\n        widgetBuilder.add(m_labelText);\r\n\r\n        // build customised layout\r\n        GridData gd = GridLayoutFactory.createDefaultLayoutData();\r\n//        gd.horizontalAlignment = SWT.FILL;\r\n        gd.widthHint = widgetBuilder.getWidthHint(10);\r\n        gd.horizontalSpan = 3;\r\n        gd.grabExcessHorizontalSpace = true;\r\n//        gd.verticalAlignment = SWT.FILL;\r\n        gd.heightHint = widgetBuilder.getHeightHint(4);\r\n        gd.verticalSpan = 3;\r\n        gd.grabExcessVerticalSpace = true;\r\n        widgetBuilder.add(m_multiLineText, gd);\r\n\r\n        widgetBuilder.add(new RCPSimpleLabel(""Vertical Span: 2nd Line...""));\r\n        widgetBuilder.add(new RCPSimpleLabel(""Vertical Span: 3rd Line...""));\r\n        widgetBuilder.newLine();\r\n        // go ahead with ""normal"" layout.\r\n\r\n        // add empty lines\r\n        widgetBuilder.add(new RCPSimpleLabel(""Filler and empty line added...""));\r\n        widgetBuilder.fillLine();\r\n        widgetBuilder.newLine();\r\n\r\n        widgetBuilder.addLine(m_birthDateText, 8);\r\n        widgetBuilder.addSkipLeftLine(m_singleLineText, 1);\r\n        widgetBuilder.addLine(m_kontoueberzugCheck);\r\n        // create one radio button for each code and associate a radio group manager\r\n\r\n        widgetBuilder.addLine(m_geschlechtCombo);\r\n\r\n    }\r\n\r\n    public void bind(ValidationManager context, Object dataModel)\r\n    {\r\n        context.bindValue(m_multiLineText, dataModel, SimpleBean.P_TEXT);\r\n//        MethodValidator validator = new AsymmetricMultilineValidator(SimpleBean.P_TEXT, new int[]{1,2,3});\r\n        MethodValidator validator = new SymmetricMultilineValidator(SimpleBean.P_TEXT, 3, 35);\r\n        context.addValidator(this, validator); \r\n    }\r\n\r\n    @Override\r\n    public void setState(EControlState state, boolean value)\r\n    {\r\n        mainSection.setState(state, value);\r\n\r\n    }\r\n\r\n    public static void main(String[] args)\r\n    {\r\n\r\n        final Object model = new SimpleBean();\r\n        final RCPFormPart part = new SandboxLayoutFormPart();\r\n        RCPFormFactory.getInstance().startTestShell(""SandboxLayoutFormPart"", part, model);\r\n    }\r\n\r\n}\r\n\r\n----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------",1254993546264
executed,command,org.eclipse.ui,3.5.1.M20090902-1000,"org.eclipse.ui.edit.text.contentAssist.proposals",1254993552972
executed,command,org.eclipse.ui,3.5.1.M20090902-1000,"org.eclipse.ui.file.save",1254993556329
executed,command,org.eclipse.ui.workbench.texteditor,3.5.0.v20090603,"org.eclipse.ui.edit.text.select.lineEnd",1254993616013
executed,command,org.eclipse.ui.workbench.texteditor,3.5.0.v20090603,"org.eclipse.ui.edit.text.select.lineEnd",1254993619520
executed,command,org.eclipse.ui,3.5.1.M20090902-1000,"org.eclipse.ui.file.save",1254993621914
executed,command,org.eclipse.ui,3.5.1.M20090902-1000,"org.eclipse.ui.edit.text.contentAssist.proposals",1254993640113
executed,command,org.eclipse.ui,3.5.1.M20090902-1000,"org.eclipse.ui.edit.text.contentAssist.proposals",1254993649828
executed,command,org.eclipse.ui,3.5.1.M20090902-1000,"org.eclipse.ui.edit.text.contentAssist.proposals",1254993654676
executed,command,org.eclipse.ui,3.5.1.M20090902-1000,"org.eclipse.ui.edit.text.contentAssist.proposals",1254993659052
executed,command,org.eclipse.ui.workbench.texteditor,3.5.0.v20090603,"org.eclipse.ui.edit.text.goto.lineEnd",1254993663037
executed,command,org.eclipse.ui,3.5.1.M20090902-1000,"org.eclipse.ui.edit.text.contentAssist.proposals",1254993667766
executed,command,org.eclipse.ui,3.5.1.M20090902-1000,"org.eclipse.ui.edit.text.contentAssist.proposals",1254993671228
executed,command,org.eclipse.ui,3.5.1.M20090902-1000,"org.eclipse.ui.file.save",1254993672956
executed,command,org.eclipse.ui,3.5.1.M20090902-1000,"org.eclipse.ui.edit.text.contentAssist.proposals",1254993713039
executed,command,org.eclipse.ui,3.5.1.M20090902-1000,"org.eclipse.ui.edit.delete",1254993721262
executed,command,org.eclipse.ui,3.5.1.M20090902-1000,"org.eclipse.ui.edit.text.contentAssist.proposals",1254993728574
executed,command,org.eclipse.ui,3.5.1.M20090902-1000,"org.eclipse.ui.edit.text.contentAssist.proposals",1254993732625
executed,command,org.eclipse.ui,3.5.1.M20090902-1000,"org.eclipse.ui.edit.undo",1254993740360
executed,command,org.eclipse.ui,3.5.1.M20090902-1000,"org.eclipse.ui.file.save",1254993747709
