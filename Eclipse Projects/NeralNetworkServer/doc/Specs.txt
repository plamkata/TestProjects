
Сървър базиран класификатор (Невронна мрежа)

Спецификация


Текущия документ съдържа кратка спецификация на проект за курса "Мрежово програмиране", 2008г - преподавател: Й. Денев.

1. Описание:
  Класификатор представлява програма, която може да "разпознава" обекти от околния свят, като ги причислява към 
определени класове. В проекта ще се реализира такъв сървър базиран класификатор, който ще може да се обучава от
статистически данни подавани от клиенти на сървъра във .csv формат. Подаваните данни трябва да представят
правилно квалифицирани обекти описани от предварително зададени характеристики. Когато класификатора бъде достатъчно
добре обучен той ще може да отговаря на клиентски заявки за класифициране (оценяване) на обекти описани с дадените 
характеристики. Например: по подадени данни за влажност на въздуха(20%), слънце(слънчево), сезон(зима), настроение(добро), 
здравно състояние(здрав) да предложи някакво подходящо действие: разходка, ски или писане на проект.

2. Изисквания: 
  Сървъра трябва да може да се конфигурира предварително по отношение на броя и формата на характеристиките, както и 
по отношение на някои параметри на използвания алгоритъм (невронна мрежа - напр. брой на скритите слоеве, повторения на 
обучаващите примери и др.). Също така сървъра трябва да може да отговаря едновременно на заявки за класификация от голям брой 
клиенти стартирайки ограничен брой процеси за обработка на заявките. Невроната мрежа ще бъде споделен ресурс за четене от тези процеси.

  Високата ефективност на сървъра по отношение на броя клиенти, отправящи заявки за обучение, би следвало да се постигне с
независимост на обработката на тези заявки. Тъй като невронната мрежа ще е споделен ресурс за тези процеси, то в случай че избереме
да пресмятаме оценките на изходните възли, съхранявайки междинните стойности във самите възли, ще се окаже, че не е възможно повече от един
клиенти да изчисляват стойностите за класовете си едновременно. Това е голям проблем що се отнася до едновременното обслужване на голям 
брой клиенти със заявки за класификация. Ето защо е необходима модификация на алгоритъма за оценяване на входните данни, която се изразява в 
пресмятане на междинните стойности във всяка една отделна заявка (извън възлите на мрежата) - т.е. в контекста на заявяващия клиент.

  Обучението на класификатора може да се извършва от много на брой обучаващти клиенти в даден момент. За сметка на това обучаващия 
клиент ще изпраща данните за обектите поотделно (евентуално, очаквайки потвърждение от сървъра, че може да продължи да праща: че данните са получени 
и валидни). Това ще даде възможност за интерактивно обучение. Сървъра от своя страна ще натрупва обучаващи примери в паметта си до 
достигане на определен лимит и след това ще обработи тези данни. По време на обработката обучаващите клиенти ще могат да пращат още примери, 
които да се натрупват в буфера, но всички заявки за класификация ще бъдат отхвърляни до приключване работата на обучаващия алгоритъм, тъй като
по време на обучението невронната мрежа активно се променя.

  Тази "обучаваща услуга" ще приема обучаващи примери асинхронно от различните обучаващи клиенти и ще натрупва тези примери до достигане на
подходяща бройка за изпълнение на алгоритъма за обучаване (алгоритъма с обратно предаване на грешката). След стартиране на алгоритъма би могло
тези клиенти да продължат да пращат обучаващи примери а те да се натрупват във вече освободения буфер на "обучаващата услуга". Това може да продължи
до запълването на този буфер, след което ако алгоритъма за обучение все още не е приключил, всяка следваща обучаваща заявка би следвало да се отхвърли.
Предполага се, че клиента на свой ред, ако му е била отказана заявка, трябва да изчака определено време и след това отново да опита да отправи своята заявка.
Важно е да се отбележи, че обучаващата услуга трябва да пази различните клиенти, чиито примери се включват в рамките на един цикъл на обучение (едно 
изпълнение на алгоритъма), за да може да им даде информация както за успешното приключване на алгоритъма, така и за евентуални проблеми при изпълнението.

  Обработката на заявки за класификация от друга страна е невъзможна по време на обучението, тъй като теглата на невронната мрежа се променят активно, за да
следват основната закономерност за разпределение по класове. Изчисленията в динамично променяща се мрежа просто няма да бъдат коректни. Добро решение в този 
случай е клиентите за класификация при опита си да направят оценка на обекта по класове да бъдат блокирани до приключване на алгоритъма за обучение и след това 
събудени, за да продължат обработката.

3. Технически характеристики:
  Класификатора ще се реализира чрез невронна мрежа с многослоен персептрон (слоевете ще може да се конфигурират). Алгоритъма, който ще
се използва за обучение на мрежата е backpropagation. Езика за реализация на проекта е Java, като към програмните средства ще добавим
framework-а WEKA, като средство за представяне на данните и тестване на алгоритъма. Комуникацията server-client ще е на ниво socket-и, а
синхронизацията между отделните процеси (евентуално нишки) ще се реализира със средставата на избрания програмен език.

4. Потребителски интерфейс:
  Както сървъра, така и клиентите ще имат конзолен потребителски интерфейс. Сървъра ще се конфигурира чрез аргументи от командния ред при първоначално 
стартиране и след това ще извежда подробна информация за извършваните действия. Най-удобно е ако обучението се извършва на един порт, а обработката на 
заявки за класификация на друг порт. От друга страна конфигурацията на невронната мрежа по отношение на характеристиките, които се иследват и техните 
допустими стойности би следвало да се изведат в отделен файл: config.arff. Като формата, в който това ще се задава е следния:

@relation weather

@attribute outlook {sunny, overcast, rainy}
@attribute temperature real
@attribute humidity real
@attribute windy {TRUE, FALSE}
@attribute play {yes, no}

Като правило - последния атрибут определя характеристиката, която ще оценяваме, а възможните и стойности определят изходните класове на мрежата.
Повече информация за формата arff (Attribute-Relation File Format) има на http://www.cs.waikato.ac.nz/~ml/weka/arff.html

  Обучаващите и отправящите заявки за спецификация клиенти ще са доста сходни. Всъщност те ще са еднакви. Единствената разлика между тях е, че единият 
ще се връзва към порта за обучение на сървъра, а другия ще се връзва към порта за обработка на заявки. И двата клиента трябва да поддържат аргументи за
host и port и също така ще могат да приемат като аргумент csv - името на файл, от който да четат примери за обучение, или стойности за оценяване. В случай, 
че е зададен такъв файл поведението на клиента би следвало да бъде: четене от файла и изпращане на стойностите към сървъра ред по ред до достигане на край
на файла; ако е достигнат край на файла трябва да се изчака отговор от сървъра за евентуално изпълнение на алгоритъма и да се затвори socket-а към сървъра;
ако по време на четене сървъра върне грешка (напр. за недостатъчно място в буфера) клиента трябва да изчака определен период от време, след което отново да
възстанови процеса на изпращане на примери. 
  
  Поради асинхронната характеристика на клиентите те могат да се използват и в конзолен вариант. Ако не се зададе 
име на csv файл би следвало клиентите да се стартират в конзолен вариант. При първаночално стартиране те се връзват към сървъра на оказания порт и хост и 
сървъра на свой ред трябва да им изпрати формата, в който той ще очаква стойностите за характеристиките на разглеждания обект. След това започва изчакваща, 
асинхронна комуникация м/у клиента и сървъра. И при изписване на запазената дума exit би следвало клиента да прекрати връзката си със сървъра и да завърши 
изпълнение.  

5. Реализация:
  Sockets and Java Thread Synchronization

6. Ограничения:
  Съществуват редица ограничения по отношение на задаването на настройки както на сървъра, така и на клиентите, но най-съществените ограничения се изразяват
в невъзможността да се конфигурира невронната мрежа по подходящ начин. Други съществени ограничения почти няма освен ограниченията в имплементцията на сървъра
и клиентите. Поради реализацията чрез socket-и броя на едновременно обслужваните клиенти, при които сървъра би се държал подобаващо е около 1000. При избор за
реализация чрез софтуерни канали или чрез събитийно базирани сървър  и клиент (съчетани с достатъчно добър connection pool management) тази характеристика би била 
далеч по-добра.

7. Бъдещи идеи и подобрения:
  Реализация чрез софтуерни канали; event-базирана реализация на сървър и клиенти; възможност за прецизна конфигурация на скритите слоеве на невронната мрежа; 
и възможност за конфигурация на други важни характеристики; използване на log файлове, вместо писане на конзола; изнасяне на конфигурациите на сървъра в 
подходящи конфиг. файлове, където редакцията на настройките е далеч по-лесна.

8. Насоки за използване:
  Може да се настрои да обработва множество полезна информация от различни отдалечени източници за финансови пазари, научни иследвания на поведение 
на непознати обекти, обработка на изображения, дори биологични процеси и в даден момент да предвижда поведението на наблюдавания обект или да определя
някакво негово качество.


Автор: Пламен Василев Александров, 4 курс, сп. Компютърни науки, фн. 80050, 2 адм. група
Дата: 23.01.2008
Дата: 5.02.2008